- version: "3.1"
  Language Changes:
    - title: Values in Hash literals and keyword arguments can be omitted
      kind: addition
      highlight: true
      importance: high
      summary: |
        In hash literals and method calls, `x:` is now a shortcut for `x: x`—take hash value from the context, with the same name as a key.
      feature: 14579
      docs:
        - https://docs.ruby-lang.org/en/3.1/syntax/literals_rdoc.html#label-Hash+Literals
        - https://docs.ruby-lang.org/en/3.1/syntax/methods_rdoc.html#label-Keyword+Arguments
        - https://docs.ruby-lang.org/en/3.1/Hash.html
      code: |
        ```ruby
        x, y = 100, 200
        # => [100, 200]
        # In hash literal
        h = {x:, y:}
        # => {:x=>100, :y=>200}

        # In method call
        p(x:, y:)
        # prints: "{:x=>100, :y=>200}"

        # Any context-available names work too, not only local variables:
        C = 'constant'
        # => "constant"
        def m()='method'
        # => :m
        {C:, m:}
        # => {:C=>"constant", :m=>"method"}

        # Undefined names behave like in any other context:
        {z:}
        # => undefined local variable or method `z' (NameError)

        # Dynamic symbols are not supported:
        name = 'x'
        {"#{name}":}
        #          ^
        # syntax error, unexpected '}' (SyntaxError)

        # ...including symbols produced from literal strings:
        {'x':}
        #    ^
        # syntax error, unexpected '}' (SyntaxError)

        TODO: self, if, etc
        ```
      notes: |
        Be aware, that using new feature in a method call without parenthesis might lead to unexpected effect:

        ```ruby
        # Useful "puts-debugging" technique: print variable values with names
        p(x:, y:)

        # ...but if you'll write it this way:
        p x:, y:
        x + y # ... some following code

        # It would be interpreted as this, for backward compatibility:
        p(x:, y: x + y)
        ```

        Therefore, if you use value omission in method calls, **always use parenthesis**!
      followups: |
        It is [still discussed](https://bugs.ruby-lang.org/issues/18396#note-4) whether Ruby should handle the problem above (unexpected continuation) more gracefully. It is possible that the behavior would change in a migration-friendly manner: first, the warning in 3.2 about `key:` at the end of the line; then, in 3.3, next line would be considered a separate statement.
      class: [Hash, Method]

    - title: Inside "endless" method definitions, method calls without parentheses are allowed
      kind: addition
      importance: low
      summary: |
        `def some_method = other_method "bar"` is now allowed, previously it was required to write `other_method("bar")` in the method's body.
      reason: When endless methods were introduced in 3.0, this syntax (named "command syntax" internally) wasn't allowed; but it was not a deliberate decision, and rather a side-effect of a parser complexity. During development of 3.1, the workaround was found to make code more consistent and refactoring from multi-line to single-line methods easier.
      feature: 17398
      docs: https://docs.ruby-lang.org/en/3.1/syntax/methods_rdoc.html
      code: |
        ```ruby
        def log(msg) = puts "#{Time.now}: #{msg}"
        # 3.0: syntax error, unexpected string literal, expecting `do' or '{' or '('
        # 3.1: successfully defined
        ```
      class: Method

    - title: Anonymous block arguments added
      kind: addition
      highlight: true
      importance: medium
      summary: If method uses its block argument only to pass to another method, it can be marked by anonymous `&`.
      reason: |
        The initial proposal for the feature is 6-year old and focused on avoiding intermediate blocks object allocation on block forwarding. It was considered redundant when block forwarding was optimized in Ruby 2.5; but then the core team decided it is actually a nice and unambiguous shortcut for methods that just pass the block further. As bloc argument is frequently called just `block`, the absence of the name doesn't affect readability.
      feature: 11256
      docs: https://docs.ruby-lang.org/en/3.1/syntax/methods_rdoc.html#label-Block+Argument
      code: |
        ```ruby
        def logged_open(filename, &)
          puts "Opening #{filename}..."
          File.open(filename, &)
        end

        logged_open('README.md') { puts _1.read(100) }
        # Prints:
        #  Opening README.md
        #  ...first 100 chars of README.md...

        # Attempt to use `&` inside a method without block parameter is an error:
        def filter(data)= data.select(&)
        # => no anonymous block parameter (SyntaxError)

        # ...and with named block parameter too
        def filter(data, &block)= data.filter(&)
        # => no anonymous block parameter (SyntaxError)

        # If you temporary want to catch a block in the method, `Kernel#proc` will help:
        def filter(data, &)
          block = proc(&)
          p block, block.call(5)
          data.filter(&)
        end
        # => :filter
        filter(1..10, &:odd?)
        # Prints:
        #  #<Proc:0x00007fe9842fa308(&:odd?) (lambda)>
        #  true
        # => [1, 3, 5, 7, 9]
        ```
      class: Method

    - title: One-line pattern matching is no longer experimental
      kind: promotion
      summary: Both versions of one-line pattern matching introduced in 3.0--using `=>` and using `in` as a `true`/`false` check--have been promoted to official language features.
      category: Pattern-matching

    - title: Expressions and non-local variables allowed in pin operator `^`
      kind: addition
      highlight: true
      importance: low
      category: Pattern-matching
      summary: On the initial implementation of the pattern matching, the only patterns that could be used in matching expression were constants, literals and pinned local variables. Since 3.1, any kind of statement can be a pattern, with extended functionality of the `^` pin operator.
      feature: [17411, 17724]
      docs: https://docs.ruby-lang.org/en/3.1/syntax/pattern_matching_rdoc.html#label-Variable+pinning
      code: |
        ```ruby
        # In Ruby 3.0, this was possible:
        {version: 12} in {version: 10..15} # range literal as a pattern
        # => true

        # But this was not, despite being intuitively similar:
        {timestamp: Time.now} in {timestamp: (Time.new(2021)..Time.new(2022))}
        # syntax error

        # In 3.1, this is possible with pinning:
        {timestamp: Time.now} in {timestamp: ^(Time.new(2021)..Time.new(2022))}
        # => true

        # Any complex expression is possible
        # ...consider years.txt has lines like "2021-2025", some ranges of years.
        Time.now.year in ^(File.read('years.txt').lines.first.then { _1.split('-') }.then { _1.to_i.._2.to_i })

        # parenthesis are mandatory, this wouldn't work:
        Time.now.year in ^rand(2021..2023)
        # syntax error
        ```

    - title: Parentheses can be omitted in one-line pattern matching
      kind: addition
      category: Pattern-matching
      importance: medium
      feature: 16182
      docs: https://docs.ruby-lang.org/en/3.1/syntax/pattern_matching_rdoc.html#label-Patterns
      code: |
        ```ruby
        [0, 1] => _, x
        # 3.0:
        #   syntax error, unexpected ',', expecting `end'
        #   [0, 1] => _, x
        #              ^
        # 3.1: success:
        x #=> 1

        {y: 2} => y:
        # 3.0
        #   syntax error, unexpected label)
        #   {y: 2} => y:
        #             ^~
        # 3.1: success:
        y #=> 2

        # Works with in: syntax, too:
        if {language: 'Ruby', version: '3.1'} in version: ('3.0'..)
          puts "Pattern-matching is cool"
        end
        # 3.0: syntax error
        # 3.1: Prints "Pattern-matching is cool"
        ```

    - title: Multiple assignment evaluation order change
      kind: change
      importance: low
      summary: L-values in multiple assignment are evaluated before r-values
      reason: |
        Multiple assignment evaluation order was unexpected: the right part of the expression was calculated before the left. While rarely crucial, this still could cause subtle bugs.
      bug: 4443
      code: |
        ```ruby
        def left1
          puts "left1"
          []
        end

        def left2
          puts "left2"
          []
        end

        def right1
          puts "right1"
          1
        end

        def right2
          puts "right2"
          2
        end

        left1[0] = right1
        # Both Ruby 3.0 and 3.1: prints left1, right1 -- the left side calculated first

        left1[0], left2[0] = right1, right2
        # 3.0: prints right1, right2, left1, left2 -- right side calculated first
        # 3.1: prints left1, left2, right1, right2 -- consistent with singular assignment
        ```

  Core Classes and Modules:
    - title: "`Class#subclasses` added"
      category: Class and Module
      kind: addition
      importance: medium
      summary: Returns all _direct_ subclasses of the class.
      feature: 18273
      docs: https://docs.ruby-lang.org/en/3.1/Class.html#method-i-subclasses
      code: |
        ```ruby
        class A
        end

        class B < A
        end

        class C < B
        end

        A.subclasses #=> [B] -- only direct descendants, no grand-children

        class << A
        end

        A.subclasses #=> [B] -- singleton class is not included either

        # Dynamic subclasses are included:
        c = Class.new(A)
        A.subclasses
        # => [#<Class:0x00007f3e45907858>, B]

        # Note that `.subclasses` doesn't hold references to the descendants, and therefore doesn't prohibit
        # them from being garbage-collected
        c = nil
        GC.start
        A.subclasses
        # => [B] -- dynamic class is gone
        ```
      notes: |
        Almost till the final release, method `#descendants` (returning all descendants, not only direct one) was also going to be introduced. But then Matz had a [change of mind](https://bugs.ruby-lang.org/issues/14394#note-33) and decided `#subclasses` covers most of the reasonable needs, and `#descendants` introduces too much complexity. It still might be considered for the future versions.
      class: Class

    - title: "`Refinement` class added"
      category: Class and Module
      kind: addition
      importance: medium
      summary: New class representing `self` inside a `refine` statement.
      bug: 17429
      docs: https://docs.ruby-lang.org/en/3.1/Refinement.html
      class: Refinement

    - title: Deprecate `include`/`extend` inside refinements
      kind: deprecation
      importance: low
      reason: The `include`/`extend` in refinements never worked (refined class wouldn't have the modules included) but were allowed.
      bug: 17429
      class: Module

    - title: "`Refinement#import_methods` added"
      category: Class and Module
      kind: addition
      importance: medium
      summary: New method similar in functionality to `Module#include` for use inside `refine` statements.
      reason: The `include`/`extend` in refinements never worked (refined class wouldn't have the modules included) but were allowed. This method was introduced as compromise replacement, limited in functionality (see **Notes**).
      bug: 17429
      code: |
        ```ruby
        module AsJSON
          def as_json_data
            JSON.parse(to_json, symbolize_names: true)
          end
        end

        Warning[:deprecated] = true # To see the warning below

        module JSONizer
          refine Array do
            include AsJSON
            # warning: Refinement#include is deprecated and will be removed in Ruby 3.2

            import_methods AsJSON
          end

          refine Hash do
            import_methods AsJSON
          end
        end

        using JSONizer

        [:bar, /baz/, Time.now].as_json_data
        # => ["bar", "(?-mix:baz)", "2021-12-25 20:47:29 +0200"]
        {'value' => 1/3r}.as_json_data
        # => {:value=>"1/3"}
        ```
      notes: |
        Unlike module including, `import_methods` works by copying the methods' bytecode to refined objects. Thus only methods defined in Ruby can be imported (because methods defined in C—including core methods—don't have bytecode). This somewhat limits the usability of the feature:

        ```ruby
        module Binread
          # try to temporarily make string into a byte-sequence...
          refine String do
            def each(&)
              each_byte(&)
            end
            import_methods Enumerable
            # Can't import method which is not defined with Ruby code: Enumerable#drop (ArgumentError)
          end
        end
        ```
      class: Refinement

    - title: "`Module#prepend` always moves to front"
      category: Class and Module
      kind: change
      importance: medium
      summary: Now, when module is prepended to the class, it always becomes first in the ancestor chain; even if it was already included.
      reason: It was noted that `prepend` is a mechanism of method redefinition that is relied upon to be performed strictly _before_ the module of the class affected; but if the class had the module already ws included (especially in complex systems and indirectly), this becomes unreliable.
      bug: 17423
      docs: https://docs.ruby-lang.org/en/3.1/Module.html#method-i-prepend
      code: |
        ```ruby
        module M
          def foo
            ["In M", *(super rescue nil)]
          end
        end

        class A
          def foo
            ["in A", *(super rescue nil)]
          end
        end

        A.include M
        A.prepend M

        A.ancestors
        # 3.0: => [A, M, Object, Kernel, BasicObject]
        # 3.1: => [M, A, M, Object, Kernel, BasicObject]
        A.new.foo
        # 3.0: => ["in A", "In M"] -- only method from included module is executed
        # 3.1: => ["In M", "in A", "In M"] -- both included AND prepended methods are executed

        # Note that relation is not symmetric: if the `prepend` happened first, `include` wouldn't affect
        # ancestors chain at all:
        class B
          def foo
            ["in B", *(super rescue nil)]
          end
        end

        B.prepend M
        B.include M

        B.ancestors
        # => [M, B, Object, Kernel, BasicObject] -- both in 3.0 and 3.1
        B.new.foo
        # => ["In M", "in B"]
        ```
      class: Module

    - title: "`Module#private`, `#public`, `#protected`, and `#module_function` return their arguments"
      category: Class and Module
      kind: change
      importance: medium
      summary: |
        For each of these methods, the following behavior is used:

          * No arguments returns `nil`
          * Single argument is returned
          * Multiple arguments are returned as an array
      reason: Allows to chain method decoration DSLs, like `memoize private :method_name`. Similar in spirit to changes to `attr_reader`/`attr_writer` behavior in Ruby 3.0
      feature: 12495
      docs:
        - https://docs.ruby-lang.org/en/3.1/Module.html#method-i-private
        - https://docs.ruby-lang.org/en/3.1/Module.html#method-i-public
        - https://docs.ruby-lang.org/en/3.1/Module.html#method-i-protected
        - https://docs.ruby-lang.org/en/3.1/Module.html#method-i-module_function
      code: |
        ```ruby
        p private # global private making all the method below private
        # => nil

        p private def m; end
        # => :m

        def m1; end
        def m2; end
        p private :m1, :m2
        # => :m1, :m2

        # Usage:
        require 'memoist'
        extend Memoist

        # This works: because memoize returns :m, and private receives it
        private memoize def m
          # ...
        end

        # In 3.0 this didn't work, but in 3.1, this does:
        memoize private def m
          # ...
        end
        ```
      class: Module

    - title: "`Method`/`UnboundMethod`: `#public?`, `#private?`, `#protected?`"
      kind: addition
      importance: low
      summary: New methods that allow for checking the visibility of a method.
      reason: For exploration, documenting, and metaprogramming (like, defining a wrapper method that would have the same visibility as original method).
      feature: 11689
      docs:
        - https://docs.ruby-lang.org/en/3.1/Method.html#method-i-public-3F
        - https://docs.ruby-lang.org/en/3.1/Method.html#method-i-protected-3F
        - https://docs.ruby-lang.org/en/3.1/Method.html#method-i-private-3F
        - https://docs.ruby-lang.org/en/3.1/UnboundMethod.html#method-i-public-3F
        - https://docs.ruby-lang.org/en/3.1/UnboundMethod.html#method-i-protected-3F
        - https://docs.ruby-lang.org/en/3.1/UnboundMethod.html#method-i-private-3F
      code: |
        ```ruby
        class A
          def m1
          end

          private def m2
          end
        end

        m1 = A.instance_method(:m1)
        # => #<UnboundMethod: A#m1() >
        m1.private?
        # => false
        m1.public?
        # => true

        m2 = A.new.method(:m2)
        # => #<Method: A#m2()>
        m2.private?
        # => true
        ```
      notes: Another idea discussed was just having `Method#visibility`, but it was hard to decide on the method's name and what it should return, while three predicates are more or less obvious.
      class: [Method, UnboundMethod]

    - title: "`Kernel#load` can load code into a specified module"
      kind: addition
      importance: medium
      summary: |
        Instead of always using a new anonymous module for `Kernel#load` if the second argument is not `false`/`nil``, use the given module if a module is provided.

        `load(filename, module)` now evaluates `filename`'s code in the context of the `module`.
      reason: The long-requested feature (the request is created almost 10 years ago!) might be useful for implementing simple helper libraries with a few unscoped methods/classes, and then scoping them while loading.
      feature: 6210
      docs: https://docs.ruby-lang.org/en/3.1/Kernel.html#method-i-load
      code: |
        ```ruby
        # Assuming the following file test-load.rb
        ENV={a: 1}

        def puts(*)
          raise NotImplementedError
        end

        class String
          def debug = p("Hello from test string")
        end

        print "Additional module loaded"

        # This would replace `ENV`, `puts` and extend core `String`, and pollute global scope with methods
        load 'test-load.rb'
        # prints "Additional module loaded"
        ENV
        # => {:a=>1}
        'test'.debug
        # prints "Hello from test string"
        puts 'bar'
        # NotImplementedError

        # This would not affect `ENV`, `puts`, and `String`, but the only use of the call would be for side-effects
        load 'test-load.rb', true
        # prints "Additional module loaded"
        ENV
        # => ...system ENV...
        'test'.debug
        # undefined method `debug' for "test":String
        puts 'bar'
        # ...prints as usual

        # 3.1+
        # This would add `ENV`, `puts` and `String` to `Context`, and will make methods available as `foo`
        module M; end
        load 'test-load.rb', M
        # prints "Additional module loaded"
        ENV
        # => ...system ENV...
        M::ENV
        # => {:a=>1}
        M::String.new.debug
        # prints "Hello from test string"
        M.instance_method(:puts)
        # => #<UnboundMethod: M#puts() test-load.rb:3> -- can be used by including M into some other module/class

        # Note that `load` wouldn't load into class:
        class C; end
        load 'test-load.rb', C # the call is successful, but C treated as just truthy value (wrap=true)
        C::ENV
        # uninitialized constant C::ENV (NameError)
        ```
      notes: |
        Scoping into a module is transitive for other `load` calls: if the loaded file `load`s more files, they also will be scoped into the module. But it is not transitive for `require`:

        ```ruby
        # assuming in test-load2.rb
        class Integer
          def debug = p "debug Int"
        end
        # ...and in test-load.rb
        load 'test-load2.rb'

        # then if we do
        module M; end
        load 'test-load.rb', M
        M::Integer.new.debug
        # prints "debug Int"

        # ...but if in test-load.rb we'll have this:
        require './test-load2'
        # ...then
        load 'test-load.rb', M
        M::Integer.debug
        # uninitialized constant M::Integer (NameError)
        1.debug
        # prints "debug Int"
        ```
      class: Kernel

    - title: "`Integer.try_convert` added"
      kind: addition
      importance: low
      summary: Safe explicit conversion method which calls `#to_int` if the argument has it, and returns `nil` otherwise.
      reason: The similar methods exist on a few other core classes, like String and Array. They are useful for implementing polymorphic methods (like `#[]` behaving differently for integer, string and range), as a safe way of type-checking/type-coercion.
      feature: 15211
      docs: https://docs.ruby-lang.org/en/3.1/Integer.html#method-c-try_convert
      code: |
        ```ruby
        Integer.try_convert(1) #=> 1
        Integer.try_convert(1.3) #=> 1
        Integer.try_convert(3/2r) #=> 1
        require 'bigdecimal'
        Integer.try_convert(BigDecimal('100000000000000000000000000000000000000000000000000000000000000'))
        #=> 100000000000000000000000000000000000000000000000000000000000000

        # If the object doesn't have #to_int, returns `nil`
        Integer.try_convert('1') #=> nil

        class MyNumber
          def to_int
            1.3
          end
        end

        # If #to_int doesn't return Integer, the error is raised (even if the result is convertable)
        Integer.try_convert(MyNumber.new)
        #=> `try_convert': can't convert MyNumber to Integer (MyNumber#to_int gives Float) (TypeError)

        # Usage in some array-alike slicing API:
        def slice(index)
          idx = Integer.try_convert(index) or
            raise ArgumentError, "Expected argument convertible to Integer, got #{index}"
          # Now `idx` is safe to use even for low-level APIs like memory addressing, it is definitely
          # Integer, even if some Float was passed initially.
        ```
      class: Integer

    - title: "`String#unpack` and `#unpack1` gain `offset:` argument"
      summary: The new argument allows to unpack data starting from the specified offset.
      importance: low
      kind: addition
      reason: |
        Handy for working with binary data of complicated shape, flow like: read one byte, decide what type/size is next data, then read this number of bytes _starting after the type tag_, then read next chunk _starting after the data already read_. Before the parameter introduction, this type of processing required string slicing, which is cumbersome and might have been inefficient.
      feature: 18254
      docs:
        - https://docs.ruby-lang.org/en/3.1/String.html#method-i-unpack
        - https://docs.ruby-lang.org/en/3.1/String.html#method-i-unpack1
      code: |
        ```ruby
        # imagine it is "type tag 1 + data in four 32-bit integers"
        data = [1, 1991, 1995, 1998, 2003].pack('CL*')
        # => "\x01\xC7\a\x00\x00\xCB\a\x00\x00\xCE\a\x00\x00\xD3\a\x00\x00"
        tag = data.unpack1('c')
        # => 1
        data.unpack('L*', offset: 1)
        # => [1991, 1995, 1998, 2003]

        # Negative offsets or out-of-bounds ones don't work
        data.unpack('L*', offset: -1)
        # in `unpack': offset can't be negative (ArgumentError)
        data.unpack('L*', offset: 20)
        # in `unpack':  offset outside of string (ArgumentError)

        # 0 works, being the same as no offset
        data.unpack('c', offset: 0)
        # => [1]
        ```
      class: String

    - title: "`MatchData#match` and `#match_length` added"
      kind: addition
      importance: medium
      summary: |
        `#match(idx)` is the same as `MatchData#[]`, but only works for singular numeric or symbolic index. `#match_length(idx)` returns the length of the `idx`s match.
      reason: It was argued that in the performance-critical code sometimes there is a need to just know the length of the substring matched, and doing it via `match[index].length` leads to creation of an intermediate string soon to be dropped, while `#match_length` doesn't do that. `#match` is added mostly for completeness (it would be weird to not have it when `#match_length` method exists).
      feature: 18172
      docs:
        - https://docs.ruby-lang.org/en/3.1/MatchData.html#method-i-match
        - https://docs.ruby-lang.org/en/3.1/MatchData.html#method-i-match_length
      code: |
        ```ruby
        m = "Ruby 3.1 is released December 25, 2021".match(/Ruby (?<version>\d\.\d) .* (?<year>\d{4})/)
        # => #<MatchData "Ruby 3.1 is released December 25, 2021" version:"3.1" year:"2021">
        m.match(1)
        # => "3.1"
        m.match(:version)
        # => "3.1"
        m.match('version')
        # => "3.1"
        m.match_length(:version)
        # => 3
        m.match(2)
        # => "2021"
        m.match_length(2)
        # => 4
        m.match(3)
        # in `match': index 3 out of matches (IndexError)
        m.match_length(3)
        # in `match_length': index 3 out of matches (IndexError)

        # ...unlike #[]
        m[3]
        # => nil

        # Realistic usage:
        text = "My credit card number is 5221-1234-5678-9000 (not really)"
        text.gsub!(/(\d{4})-(\d{4})-(\d{4})-(\d{4})/) {
          m = Regexp.last_match
          "#{m.match(1)}-#{'*' * m.match_length(2)}-#{'*' * m.match_length(3)}-#{m.match(4)}"
        }
        # => "My credit card number is 5221-****-****-9000 (not really)"
        ```
      class: MatchData

    - title: "`Time.new`, `.at` and `.now` gain `in:` argument"
      kind: addition
      importance: medium
      highlight: true
      summary: The new parameter is accepting offsets or timezone objects, and (finally!) allows to easily construct time in desired timezone.
      feature: 17485
      docs:
        - https://docs.ruby-lang.org/en/3.1/Time.html#method-c-new
        - https://docs.ruby-lang.org/en/3.1/Time.html#method-c-at
        - https://docs.ruby-lang.org/en/3.1/Time.html#method-c-now
      code: |
        ```ruby
        Time.new(2021, 12, 24, in: '+09:00')
        # => 2021-12-24 00:00:00 +0900
        Time.new(2021, 12, 24, in: 'UTC')
        #  => 2021-12-24 00:00:00 UTC

        # This was previously possible only with "pass all params" signature
        # Ruby 3.0: tz was only a positional argument:
        Time.new(2021, 12, 24, 0, 0, 0, '+09:00')
        # => 2021-12-24 00:00:00 +0900

        # This was previously not possible to do in one call: ::now with timezone
        Time.now(in: '+09:00')
        # => 2021-12-21 18:33:51.583436226 +0900
        Time.now
        # => 2021-12-21 11:34:00.258235705 +0200 -- my local timezone, for comparison

        # This was not possible either: ::at with timezone
        timestamp = Time.now.to_i
        # => 1640079354
        Time.at(timestamp, in: '+09:00')
        # => 2021-12-21 18:35:54 +0900

        # Timezone objects are supported, too
        require 'tzinfo'
        zone = TZInfo::Timezone.get('America/New_York')
        Time.now(in: zone)
        # => 2021-12-21 04:37:25.522169768 -0500
        Time.now(in: zone).zone
        # => #<TZInfo::DataTimezone: America/New_York>
        ```
      class: Time

    - title: "`Time#strftime` supports `-00:00` offset"
      kind: addition
      importance: low
      summary: |
        `%-z` allows to format "negative zero" offset for Time.
      reason: |
        RFC 3339 [defines a nuance](https://datatracker.ietf.org/doc/html/rfc3339#section-4.3) of offset formatting: offset `"+00:00"` in some service response declares that UTC is the preferred timezone for some context; while `"-00:00"` declares that preferred timezone is unknown, that's why data is in UTC.
      feature: 17544
      docs: https://docs.ruby-lang.org/en/3.1/Time.html#method-i-strftime
      code: |
        ```ruby
        t = Time.now.utc
        # => 2021-12-26 18:47:52.979940556 UTC -- yeah, I am still working on a changelog a day after the release :(
        t.strftime('%H:%M%z')
        # => "18:47+0000"
        t.strftime('%H:%M%-z')
        # => "18:47-0000"
        t.strftime('%H:%M%-:z')
        # => "18:47-00:00"
        t.strftime('%H:%M%-::z')
        # => "18:47-00:00:00"
        ```
      class: Time

    - title: "`Struct#new` warns when passing keywords to a non-keyword-initialized struct"
      kind: addition
      importance: low
      reason: After keyword-inited stucts have been introduced, it is easy to forget the actual protocol of some struct, and try to initialized it with keyword arguments—which, if the struct is not keyword-inited, would raise no error, but produce an unexpected result.
      feature: 16806
      code: |
        ```ruby
        Person = Struct.new(:name, :age)
        # Proper initialization:
        Person.new('Jane', 32)
        #=> #<struct Person name="Jane", age=32>

        # I forgot it is not initialized by keywords, expected to initialize both fields,
        # but it would actually be treated as Person.new({name: 'Jane', age: 32}, nil)
        Person.new(name: 'Jane', age: 32)
        # warning: Passing only keyword arguments to Struct#initialize will behave differently from Ruby 3.2. Please use a Hash literal like .new({k: v}) instead of .new(k: v).
        #=> #<struct Person name={:name=>"Jane", :age=>32}, age=nil>

        # If the struct is really initialized by a hash, use {} to signify you know what you do
        Locale = Struct.new(:translations)
        Locale.new({user: 'користувач', application: 'застосунок'})
        # => #<struct Locale translations={:user=>"користувач", :application=>"застосунок"}>
        # ...no warning produced

        # The warning is produced only if the hash is the ONLY argument
        Locale = Struct.new(:lang, :translations)
        Locale.new(:ua, user: 'користувач', application: 'застосунок')
        #=> #<struct Locale lang=:ua, translations={:user=>"користувач", :application=>"застосунок"}>
        # ...no braces necessary, no warning
        ```
      class: Struct

    - title: "`StructClass#keyword_init?` added"
      kind: addition
      importance: low
      summary: New method allows to check whether the `Struct`-produced class is initialized by keywords.
      reason: Helpful for meta-programming and generic processing of data, like serializing/deserializing.
      feature: 18008
      docs: https://docs.ruby-lang.org/en/3.1/Struct.html#method-c-keyword_init-3F
      code: |
        ```ruby
        Struct.new(:name, :age).keyword_init?                       #=> nil
        Struct.new(:name, :age, keyword_init: true).keyword_init?   #=> true
        Struct.new(:name, :age, keyword_init: false).keyword_init?  #=> false

        # Potential usage:
        def deserialize(struct_class, **data)
          if struct_class.keyword_init?
            struct_class.new(**data)
          else
            struct_class.new(*data.values)
          end
        end
        ```
      class: Struct

    - title: "`Enumerable#compact` and `Enumerator::Lazy#compact` added"
      kind: addition
      importance: medium
      reason: |
        `#compact` was previously defined only on a particular classes like `Array` and `Hash`, but being a synonym for `reject(&:nil?)`, it is reasonable to have in generic `Enumerable`. Especially useful in lazy enumeration to produce still-lazy sequences with `compact` applied.
      feature: 17312
      docs:
        - https://docs.ruby-lang.org/en/3.1/Enumerable.html#method-i-compact
        - https://docs.ruby-lang.org/en/3.1/Enumerator/Lazy.html#method-i-compact
      code: |
        ```ruby
        # quickly imitate some slow or infinite stream producing data with nils possible:
        stream = Enumerator.produce { [nil, 1, 'test'].sample }.lazy

        stream.compact.first(5)
        # 3.0: NoMethodError (undefined method `compact' for #<Enumerator::Lazy: #<Enumerator: #<Enumerator::Producer:0x000055e8ffd38388>:each>>)
        # 3.1: => ["test", 1, 1, "test", "test"]

        # In 3.0, this already worked, which made absence of .compact even more confusing:
        stream.reject(&:nil?).first(5)
        # => ["test", "test", 1, "test", 1]

        # Usage in regular enumerable objects:
        require 'set'
        Set[1, nil, 2].compact
        # 3.0: NoMethodError (undefined method `compact' for #<Set: {1, nil, 2}>)
        # 3.1: => [1, 2] -- not ideal (it would be better to see Set[1, 2]), but better
        ```
      notes: |
        `Hash`, despite being `Enumerable`, has its own [#compact] method definition since [Ruby 2.4](2.4.html#hashcompact-and-compact), which just removes all key-value pairs where values are `nil`.
      class: [Enumerable, Enumerator::Lazy]

    - title: "`Enumerable#tally` now accepts an optional hash to update"
      kind: addition
      importance: medium
      summary: The hash is updated with the new `tally` numbers, allowing to accumulate stats from several enumerables efficiently and succinctly.
      feature: 17744
      docs: https://docs.ruby-lang.org/en/3.1/Enumerable.html#method-i-tally
      code: |
        ```ruby
        week1_shifts = ['John', 'Jane', 'Hassim', 'John', 'Olexa', 'Olexa', 'Jane']
        week2_shifts = ['Jane', 'Jane', 'Miranda', 'John', 'Hassim', 'Olexa', 'John']

        stats = {}
        week1_shifts.tally(stats)
        #=> {"John"=>2, "Jane"=>2, "Hassim"=>1, "Olexa"=>2}
        week2_shifts.tally(stats) # add it to the previous stats
        #=> {"John"=>4, "Jane"=>4, "Hassim"=>2, "Olexa"=>3, "Miranda"=>1}

        # Only hashes or objects implicitly convertible into hash are allowed:
        require 'ostruct'
        week1_shifts.tally(OpenStruct.new) # maybe having #[]= is enough?..
        # in `tally': can't convert OpenStruct to Hash (OpenStruct#to_hash gives NilClass) (TypeError)

        # Hash descendants can be used as argument
        gem 'hashie'
        require 'hashie'
        stats = Hashie::Mash.new # Subclass of Hash which allows `.key` access
        res = week1_shifts.tally(stats)
        # => {"John"=>2, "Jane"=>2, "Hassim"=>1, "Olexa"=>2}
        res.class
        # => Hashie::Mash
        res.John
        # => 2
        ```
      class: Enumerable

    - title: "`Enumerable#each_cons` and `#each_slice` return a receiver"
      kind: addition
      importance: medium
      reason: Before 3.1, both methods returned `nil`, making it inconvenient to use in chained computations. This was also inconsistent with `#each`, which returns a receiver.
      github-pull-request: 1509
      docs:
        - https://docs.ruby-lang.org/en/3.1/Enumerable.html#method-i-each_cons
        - https://docs.ruby-lang.org/en/3.1/Enumerable.html#method-i-each_slice
      code: |
        ```ruby
        Item = Struct.new(:value, :next)

        list = ('a'..'e').map { Item.new(_1) }
                        .each_cons(2) { |item, next_item| item.next = next_item }
        # => [
        #   #<struct Item value="a", next=#<struct Item value="b", ...>,
        #   ...
        #   ...

        # Before Ruby 3.1, one would need to write:
        list = ('a'..'e').map { Item.new(_1) }
        # this would return nil, so can't be chained
        list.each_cons(2) { |item, next_item| item.next = next_item }
        ```
      class: Enumerable

    - title: "`Array#intersect?` added"
      kind: addition
      importance: high
      summary: Method checks if two arrays intersect, e.g. have at least one item in common.
      reason: Checking intersection is typical operation (is "current user roles intersect with admin roles?"), but without this method, it typically required to write `!(ary1 & ary2).empty?`, which is cumbersome and produces an intermediate array.
      feature: 15198
      docs: https://docs.ruby-lang.org/en/3.1/Array.html#method-i-intersect-3F
      code: |
        ```ruby
        [1, 2, 3, 4].intersect?([1, 11, 111]) #=> true
        [1, 2, 3, 4].intersect?([11, 111]) #=> false

        # As with other set-alike method, items comparison are performed with #eql? which is in some cases
        # stricter than #==
        [1] == [1.0]
        # => true
        [1].intersect?([1.0])
        # => false
        ```
      notes: |
        * As it is with [&](https://docs.ruby-lang.org/en/3.1/Array.html#method-i-26), the new method treats arrays as sets of values with order ignored, so the semantic is just "if any value of array 1 is present in array 2", not some more strict check (like "if elements at the end of array 1 are the same as elements at the beginning of array 2").
        * The complexity of the method is roughly `O(size1+size2)`.
      class: Array

    - title: "`Thread::Queue#initialize` can accept initial values"
      kind: addition
      importance: low
      reason: Despite the fact that `Thread::Queue` is a specialized collection for safe data exchange in a multi-threaded context, it is considered to frequently have some initial set of values to process (like list of workers), new method call-sequence simplifies that.
      feature: 17327
      docs: https://docs.ruby-lang.org/en/3.1/Thread/Queue.html#method-c-new
      code: |
        ```ruby
        queue = Thread::Queue.new(['task1', 'task2', 'task3'])
        # => #<Thread::Queue:0x00007f434de1b800>

        producer = Thread.new do
          while !queue.empty?
            task = queue.pop
            puts "procesing #{task}"
          end
        end

        producer.join
        # procesing task1
        # procesing task2
        # procesing task3

        # Any class responding to #to_a, and any Enumerable can be used as a constructor:
        queue = Thread::Queue.new(File.open('tasks.csv').each_line)
        # => #<Thread::Queue:0x00007f434de18998>
        ```
      class: Thread::Queue

    - title: "`IO::Buffer` added"
      kind: addition
      highlight: true
      importance: medium
      summary: A new class representing low-level I/O abstraction. Internally, uses OS mechanisms to directly use memory-mapping of files and internal Ruby String representation.
      reason: The feature was requested for implementing non-blocking `#io_read` and `#io_write` for `FiberScheduler`, but probably will find other usages once matured.
      feature: 18020
      docs: https://docs.ruby-lang.org/en/3.1/IO/Buffer.html
      code: |
        _This is a big new class, see its docs for detailed examples of usage, they are quite succinct._
      class: IO::Buffer

    - title: "`File.dirname` gains optional `level` param to go up the directory tree"
      kind: addition
      importance: medium
      feature: 12194
      docs: https://docs.ruby-lang.org/en/3.1/File.html#method-c-dirname
      code: |
        ```ruby
        path = "/home/zverok/projects/ruby/README.md"
        File.dirname(path)
        # => "/home/zverok/projects/ruby"
        File.dirname(path, 1) # same as above
        # => "/home/zverok/projects/ruby"
        File.dirname(path, 2)
        # => "/home/zverok/projects"
        File.dirname(path, 3)
        # => "/home/zverok"
        File.dirname(path, 100)
        # => "/"
        File.dirname(path, 0) # no-op
        # => "/home/zverok/projects/ruby/README.md"
        File.dirname(path, -1)
        # in `dirname': negative level: -1 (ArgumentError)
        ```
      notes: Unfortunately, [Pathname#dirname](https://docs.ruby-lang.org/en/3.1/Pathname.html#method-i-dirname) is not updated to have a similar new argument.
      class: File

    - title: "`Marshal.load` accepts a `freeze:` option"
      kind: addition
      importance: low
      summary: If `freeze:true` is passed, `#load` will return a deeply frozen object graph.
      reason: Besides obvious immutability merits, constructing frozen graph may lead to lower memory consumption, because frozen strings are deduplicated.
      feature: 18148
      docs: https://docs.ruby-lang.org/en/3.1/Marshal.html#method-c-load
      code: |
        ```ruby
        serialized = Marshal.dump(['value1', 'value2', 'value1', 'value2'])

        deserialized = Marshal.load(serialized)
        deserialized.map(&:frozen?)
        # => [false, false, false, false]
        deserialized.map(&:object_id)
        # => [1023900, 1023920, 1023940, 1023960] -- 4 different objects

        deserialized = Marshal.load(serialized, freeze: true)
        deserialized.map(&:frozen?)
        # => [true, true, true, true]
        deserialized.map(&:object_id)
        # => [1039360, 1039380, 1039360, 1039380] -- only 2 different objects, object_ids repeating

        # The only type of objects not frozen are class/module:
        MyType = Struct.new(:a, :b)
        serialized = Marshal.dump(MyType)
        deserialized = Marshal.load(serialized, freeze: true)
        deserialized.frozen? # => false
        # That's because Marshal.load doesn't "create" those objects, just finds the correspondence:
        Object.send(:remove_const, :MyType)
        Marshal.load(serialized)
        # undefined class/module MyType (ArgumentError)
        # ...therefore, making that corresponding module frozen would be unexpected
        ```
      class: Marshal

    - title: "`Thread#native_thread_id` added"
      kind: addition
      importance: low
      category: Concurrency
      summary: Returns OS-specific thread ID.
      reason: The method might be useful for low-level debugging, and for system calls requiring "real" thread id.
      feature: 17853
      docs: https://docs.ruby-lang.org/en/3.1/Thread.html#method-i-native_thread_id
      code: |
        ```ruby
        # On my Ubuntu:

        Thread.current.native_thread_id
        # => 2735439
        t = Thread.new { sleep(1) }
        t.native_thread_id
        # => 2746533
        sleep(5) # -- allow t to finish (non-deterministic though!)
        t.native_thread_id
        # => nil
        ```
      notes: It is documented that `native_thread_id` might change through the thread lifetime in Ruby implementations that use `M:N` threading model (e.g. `M` Ruby threads is mapped on `N` OS threads, with the nature of mapping decided by the interpreter).
      class: Thread

    - title: "`Process._fork` added"
      kind: addition
      importance: low
      category: Concurrency
      summary: The new method is the process forking implementation which is guaranteed to be used by  `Process.fork`, `Kernel#fork`, and `IO.popen`.
      reason: The method is meant to be overridable by libraries that need to add some hook/additional processing (like freeing DB connections) on forking. Previously, this was inconvenient due to the fact that `Process.fork` and `Kernel#fork` were different methods, not relying on each other.
      feature: 17795
      docs: https://docs.ruby-lang.org/en/3.1/Process.html#method-c-_fork
      code: |
        ```ruby
        module ForkMonitor
          def _fork(...)
            puts "Before fork : in #{Process.pid}"
            super.tap { puts "After fork  : in #{Process.pid}" }
          end
        end

        Process.singleton_class.prepend(ForkMonitor)

        puts "Main process: in #{Process.pid}"
        pid = fork { puts "Forked body : in #{Process.pid}" }
        puts "Wating for       #{pid}"
        Process.waitpid(pid) if pid
        ```
        This prints:
        ```
        Main process: in 2052974
        Before fork : in 2052974
        After fork  : in 2052974
        Wating for       2052975
        After fork  : in 2052975  -- note that AFTER code is performed both for parent and child
        Forked body : in 2052975
        ```
      notes: |
        * The method should **never** be called directly; the only reason for it to exist is to be redefinable
        * The method should call `super`, and return what it had returned (it would become a return value of `fork`, e.g. child process' `pid`)
      class: Process

    - title: "Fiber Scheduler: New hooks"
      kind: addition
      importance: low
      highlight: true
      category: Concurrency
      summary: Continuing work on non-blocking Fiber and Fiber Scheduler concept [introduced in 3.0](3.0.html#non-blocking-fiber-and-scheduler), new optional hooks were introduced to support non-blocking DNS resolution (`#address_resolve`), IO (`#io_read`/`#io_write`)
      feature: [17370, 17470, 18020]
      docs:
        - https://docs.ruby-lang.org/en/3.1/Fiber/SchedulerInterface.html#method-i-address_resolve
        - https://docs.ruby-lang.org/en/3.1/Fiber/SchedulerInterface.html#method-i-timeout_after
        - https://docs.ruby-lang.org/en/3.1/Fiber/SchedulerInterface.html#method-i-io_read
        - https://docs.ruby-lang.org/en/3.1/Fiber/SchedulerInterface.html#method-i-io_write
      code: |
        See code examples in 3.0 changelog for general demo of using Fiber Scheduler. As no simple implementation is available, it is complicated to show an example of new hooks in play.
      notes: |
        * Just to remind: Ruby does not include the default implementation of Fiber Scheduler, but the maintainer of the feature, Samuel Williams, provides one in his gem [Async](https://github.com/socketry/async) which is Ruby 3.1-compatible already.
        * `IO::Buffer` introduced to provide a possibility for Fiber scheduler implementations to efficiently do the low-level I/O in a non-blocking manner.
      class: Fiber::SchedulerInterface

    - title: "Ractors can access module instance variables"
      kind: change
      importance: medium
      category: Concurrency
      summary: |
        Ractors, introduced in 3.0 to solve a problem of GVM (global virtual matchine lock), have a strict notion of "shareability". Non-main Ractors can't directly access any names defined outside of them except for classes/modules and frozen constants. One improvement was made to this model: allow to access module-wide instance variables.
      reason: |
        Calling `SomeClass.some_method` from inside Ractor is generally OK, unless the method changes the class'/module's internal variables (for example `SomeObject.new` maintains a global cache of all objects constructed)—in this case you'll see an `IsolationError`. So far, it corresponds to expectations of Ractor's data sharing model. But this expectation is broken if some of the module's methods uses immutable data stored in instance variable: intuitively it doesn't break isolation, but still didn't work. Now this limitation is relaxed.
      feature: 17592
      docs: https://docs.ruby-lang.org/en/3.1/Ractor.html#class-Ractor-label-Shareable+and+unshareable+objects
      code: |
        ```ruby
        class APIClient < Struct.new(:version, :use_https, keyword_init: true)
          def self.setup!(**defaults)
            @defaults = defaults.freeze
          end

          def self.make
            new(**@defaults)
          end
        end

        APIClient.setup!(version: 1, use_https: true) # sets immutable instance variable @defaults

        Ractor.new {
          p APIClient.make # uses that variable, should be safe
          # 3.0: in `make': can not access instance variables of classes/modules from non-main Ractors (Ractor::IsolationError)
          # 3.1: => #<struct APIClient version=1, use_https=true>
        }.take
        ```
      class: Ractor

    - title: "`Thread::Backtrace.limit` added"
      kind: addition
      importance: low
      category: Internals
      summary: Returns value set by `--backtrace-limit` command-line option (which is used in Exception#full_message to format backtrace).
      reason: The ability to read the parameter might be useful for custom error formatters.
      feature: 17479
      docs: https://docs.ruby-lang.org/en/3.1/Thread/Backtrace.html#method-c-limit
      code: |
        ```
        $ ruby -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
        −1
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
            from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
            from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
            from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
            from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
            from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
            from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
            from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
            from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
            from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
            from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
            from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
            from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
            from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
            from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
            from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
            from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
            from -e:1:in `<main>'

        $ ruby --backtrace-limit 2 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
        2
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
            from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
            from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
            ... 7 levels...
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
            from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
            from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
            ... 7 levels...

        $ ruby --backtrace-limit 0 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
        0
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
            ... 9 levels...
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
            ... 9 levels...
        ```
      class: Thread::Backtrace

    - title: "`GC.measure_total_time`, `.measure_total_time=`, `.total_time`, `.stat` added"
      kind: addition
      importance: medium
      category: Internals
      summary: New methods added to measure time spent in garbage collection.
      feature: 10917
      docs:
        - https://docs.ruby-lang.org/en/3.1/GC.html#method-c-measure_total_time
        - https://docs.ruby-lang.org/en/3.1/GC.html#method-c-measure_total_time-3D
        - https://docs.ruby-lang.org/en/3.1/GC.html#method-c-stat
        - https://docs.ruby-lang.org/en/3.1/GC.html#method-c-total_time
      code: |
        ```ruby
        GC.total_time  # => 10903796 -- nanoseconds at script start
        GC.stat[:time] # => 10 -- milliseconds at script start

        30_000.times.map { Object.new }

        GC.start

        # After some GCing
        GC.total_time  # => 20483486 -- nanoseconds
        GC.stat[:time] # => 20 -- milliseconds

        GC.measure_total_time= false

        30_000.times.map { Object.new }

        GC.start

        # Measuring was disabled, same values as above
        GC.total_time  # => 20483486
        GC.stat[:time] # => 20
        ```
      notes: It is stated that measurement can introduce overhead, but _it is enabled by default_.
      class: GC

    - title: "`TracePoint.allow_reentry` added"
      kind: addition
      importance: low
      category: Internals
      summary: Normally, during handling of `TracePoint` event, all other active `TracePoint` handlers wouldn't be called. Since Ruby 3.1, the handler can wrap some of its code into `TracePoint.allow_reentry { ... }` and inside that block, other handlers (including the current one) _will_ be invoked.
      reason: The issue was raised by author of the [byebug](https://github.com/deivid-rodriguez/byebug) debugger. Debugging sessions are implemented with `TracePoint` API, and when the program is inside a debugging session, it is actually inside one of the handlers. Thus, all other libraries relying on `TracePoint` API would not work during the session—and one of them is [zeitwerk](https://github.com/fxn/zeitwerk), Rails code reloader.
      feature: 15912
      docs: https://docs.ruby-lang.org/en/3.1/TracePoint.html#method-c-allow_reentry
      code: |
        ```ruby
        # Without reentry
        # ---------------

        line_handler = TracePoint.new(:line) do |tp| # invoked for each statement
          next if tp.path != __FILE__ # only work in this file
          puts "Line handler"
          binding.eval("class C; end")
        end.enable

        class_handler = TracePoint.new(:class) do |tp| # invoked for each class definition
          puts "Class handler"
        end.enable

        class B
        end

        # This script will print "Class handler" only once: when inside :line
        # handler, all other handlers are ignored, and `class C; end` is NOT invoking the class_handler


        # With reentry
        # ------------

        line_handler = TracePoint.new(:line) do |tp| # invoked for each statement
          next if tp.path != __FILE__ # only work in this file
          next if (__LINE__..__LINE__+3).cover?(tp.lineno) # don't be invoked from itself
          puts "Line handler"
          TracePoint.allow_reentry { binding.eval("class C; end") }
        end.enable

        class_handler = TracePoint.new(:class) do |tp| # invoked for each class definition
          puts "Class handler"
        end.enable

        class B
        end

        # This will print "Class handler" twice: inside allow_reentry block in :line
        # handler, other handlers are enabled.
        ```
      notes: |
        The default behavior (no reentry) is necessary to protect from infinite recursion; when allowing reentry, extreme precautions should be taken (note the second `if` inside `:line` handler: without it, every line inside the handler would invoke itself).
      class: TracePoint

    - title: "`$LOAD_PATH.resolve_feature_path` no longer raises on unfound name"
      kind: change
      importance: low
      category: Internals
      summary: Since being added [in 2.6](2.6.html#rubyvmresolve_feature_path) (then named `RubyVM.resolve_feature_path`), the method have raised when the requested name wouldn't be found. It was fixed in 3.1 to just return `nil`.
      reason: It was argued that raising `LoadError` makes method looks like it has a side effect instead of just being a query method, and makes it inconvenient to use.
      feature: 16043
      docs: https://docs.ruby-lang.org/en/3.1/globals_rdoc.html
      code: |
        ```ruby
        $LOAD_PATH.resolve_feature_path('garbage111')
        # 3.0: LoadError (cannot load such file -- garbage111)
        # 3.1: => nil
        ```

- version: "3.0"
  Language Changes:
    - title: "Keyword arguments are now fully separated from positional arguments"
      kind: change
      importance: high
      highlight: true
      summary: |
        The separation which started in 2.7 with deprecations, is now fully finished. It means keyword arguments are not a "syntax sugar" on top of hashes, and they never converted into each other implicitly:
      feature: 14183
      code: |
        ```ruby
        def old_style(name, options = {})
        end

        def new_style(name, **options)
        end

        new_style('John', {age: 10})
        # Ruby 2.6: works
        # Ruby 2.7: warns: Using the last argument as keyword parameters is deprecated; maybe ** should be added to the call
        # Ruby 3.0: ArgumentError (wrong number of arguments (given 2, expected 1))
        new_style('John', age: 10)
        # => works
        h = {age: 10}
        new_style('John', **h)
        # => works, ** is mandatory

        # The last hash argument still allowed to be passed without {}:
        old_style('John', age: 10)
        # => works
        ```
      notes: There is a [big and detailed explanation](https://www.ruby-lang.org/en/news/2019/12/12/separation-of-positional-and-keyword-arguments-in-ruby-3-0/) of the separation reasons, logic, and edge cases on Ruby site, written at the dawn of 2.7, so we will not go into more details here.
      class: Method

    - title: Procs with "rest" arguments and keywords change of autosplatting behavior
      kind: change
      importance: medium
      summary: Just a leftover from the separation of keyword arguments.
      feature: 16166
      code: |
        ```ruby
        block = proc { |*args, **kwargs| puts "args=#{args}, kwargs=#{kwargs}"}
        block.call(1, 2, a: true)
        # Ruby 2.7: args=[1, 2], kwargs={:a=>true} -- as expected
        # Ruby 3.0: args=[1, 2], kwargs={:a=>true} -- same
        block.call(1, 2, {a: true})
        # Ruby 2.7:
        #  warning: Using the last argument as keyword parameters is deprecated
        #  args=[1, 2], kwargs={:a=>true} -- but extracted to keyword args nevertheless
        # Ruby 3.0:
        #  args=[1, 2, {:a=>true}], kwargs={} -- no attempt to extract hash into keywords, and no error/warning
        ```
      class: Proc

    - title: "Arguments forwarding (`...`) supports leading arguments"
      kind: addition
      importance: medium
      reason: Argument forwarding, when introduced in 2.7, was able to forward only all-or-nothing. It turned out to be not enough. One of the important usages for leading arguments are cases like `method_missing` and other DSL-defined methods that need to pass to the nested method `:some_symbol` + all of the original arguments.
      feature: 16378
      docs: https://docs.ruby-lang.org/en/master/syntax/methods_rdoc.html#label-Argument+forwarding
      code: |
        ```ruby
        def request(method, url, headers: {})
          puts "#{method.upcase} #{url} (headers=#{headers})"
        end

        def get(...)
          request(:get, ...)
        end

        get('https://example.com', headers: {content_type: 'json'})
        # GET https://example.com (headers={:content_type=>"json"})

        # Leading arguments may be present both in the call and in the definition:
        def logged_get(message, ...)
          puts message
          get(...)
        end

        logged_get('Logging', 'https://example.com', headers: {content_type: 'json'})
        ```
      notes: |
        * "all arguments splat" `...` should be the last statement in the argument list (both on a declaration and a call)
        * on a method declaration, arguments before `...` can only be positional (not keyword) arguments, and can't have default values (it would be `SyntaxError`);
        * on a method call, arguments passed before `...` can't be keyword arguments (it would be `SyntaxError`);
        * make sure to check your punctuation thoroughly, because `anything ...` is a syntax for endless range, those constructs are valid syntax, but would do not what is expected:

          ```ruby
          def delegates(...)
            # call without "()" -- actually parsed as (p()...)
            p ...
            # Prints nothing, but warns: warning: ... at EOL, should be parenthesized?

            # "," accidentally missing after 1, there is just one argument: 1...
            p(1 ...)
            # Prints "1..."

            p(1, ...)
            # Prints, as expected:
            #   1
            #   5
          end

          delegates(5)
          ```
      class: Method

    - title: Single-statement methods can be defined without `end`
      kind: addition
      importance: high
      summary: Methods of exactly one statement now can be defined with syntax `def method() = statement`.
      reason: |
        Ruby's `end`s (unlike C-like languages' `{}`) are generally OK for Rubyists, but make small utility methods look more heavy than they should. For small utility methods with body containing just one short statement like:

        ```ruby
        def available?
          !@internal.empty?
        end
        ```

        ...the "proper" definition might look so heavy that one will decide against it to leave the class more readable (and instead make class' clients to just do `obj.internal.empty?` themselves, making it less semantical). For such cases, a shortcut one-line definition may change the perceiving of utility method creation:

        ```ruby
        def available? = !@internal.any?
        def finished? = available? && @internal.all?(&:finished?)
        def clear = @internal.clear
        ```
      feature: 16746
      docs: https://docs.ruby-lang.org/en/master/syntax/methods_rdoc.html
      code: |
        ```ruby
        def dbg = puts("DBG: #{caller.first}")

        dbg
        # Prints: DBG: test.rb:3:in `<main>'

        # The method definition supports all kinds of arguments:
        def dbg_args(a, b=1, c:, d: 6, &block) = puts("Args passed: #{[a, b, c, d, block.call]}")
        dbg_args(0, c: 5) { 7 }
        # Prints: Args passed: [0, 1, 5, 6, 7]

        # For argument definition, () is mandatory
        def square x = x**2
        # syntax error, unexpected end-of-input -- because Ruby treats it as
        #   def square(x = x**2)
        # ...e.g. an argument with default value, referencing itself, and no method body

        # This works
        def square(x) = x**2
        square(100) # => 10000

        # To avoid confusion, defining method names like #foo= is prohibited
        class A
          # SyntaxError "setter method cannot be defined in an endless method definition":
          def attr=(val) = @attr = val

          # Other suffixes are OK:
          def attr?() = !!@attr
          def attr!() = @attr = true
        end

        # funnily enough, operator methods are OK, including #==
        class A
          def ==(other) = true
        end

        p A.new == 5 # => true

        # any singular expression can be method body

        # This works:
        def read(name) = File.read(name)
                            .split("\n")
                            .map(&:strip)
                            .reject(&:empty?)
                            .uniq
                            .sort

        # Or even this, though, what's the point?..
        def weird(name) = begin
                            data = File.read(name)
                            process(data)
                            true
                          rescue
                            false
                          end

        # inside method body, method calls without parentheses cause a syntax error:
        def foo() = puts "bar"
        #                ^ syntax error, unexpected string literal, expecting `do' or '{' or '('

        # This is due to parsing ambiguity and is aligned with some other places, like
        x = 1 + sin y
        #           ^ syntax error, unexpected tIDENTIFIER, expecting keyword_do or '{' or '('
        ```
      notes: |
        * The initial proposal seems to be a good-natured April Fool's joke, then everybody suddenly liked it, and, with a slight change of syntax, it was accepted;
        * Feature is marked as EXPERIMENTAL, but it does NOT produce a warning, it is deliberate, see discussion in [Misc #17399](https://bugs.ruby-lang.org/issues/17399).
      followups: In Ruby 3.1, the requirement to wrap method calls in parenthesis inside endless method body [was removed](3.1.html#inside-endless-method-definitions-method-calls-without-parenthesis-are-allowed).
      class: Method

    - title: "Pattern matching no longer experimental"
      kind: promotion
      importance: low
      category: Pattern Matching
      summary: Pattern matching, introduced in 2.7, is no longer experimental.
      feature: 17260

    - title: One-line pattern matching with `=>`
      kind: addition
      importance: medium
      category: Pattern Matching
      reason: |
        This is an interesting one. Two facts were discussed between 2.7 and 3.0: the fact that in most of the other languages one-line pattern matching has a different order (`<pattern> <operator> <data>`) than introduced in Ruby 2.7 (`<data> in <pattern>`); and the idea of "rightward assignment operator" `=>` for more natural chaining. And then, at some point, ideas converged most fruitfully.
      feature: 17260
      docs: https://docs.ruby-lang.org/en/3.0.0/syntax/pattern_matching_rdoc.html
      code: |
        ```ruby
        # match and unpack:
        {db: {user: 'John', role: 'admin'}} => {db: {user:, role:}}
        p [user, role] # => ["John", "admin"]

        # pattern-matching as a rightward assignment for long experessions:
        File.read('test.txt')
            .split("\n")
            .map(&:strip)
            .reject(&:empty?)
            .first(10) => lines

        p lines # first 10 non-empty lines of the file

        # unpacking+assignment is extremely powerful:
        (1..10).to_a.shuffle => [*before, (2..4) => threshold, *after]
        # ...in input sequence, find first entry in range 2..4, put it into `threshold`,
        # and split parts of the sequence before/after it
        p [before, threshold, after]    # your results might be different due to shuffle :)
        # => [[7, 5, 8], 3, [1, 10, 6, 9, 4, 2]]

        # The things can get really out of hand quickly:
        Time.now.hour => ..9 | 18.. => non_working_hour
        ```
      notes: |
        * Feature is marked as EXPERIMENTAL, will warn so on an attempt of usage, and may change in the future;
        * But simple assignment usage (`data => variable`) is **not** considered experimental and is here to stay;
        * One quirk that might be non-obvious: pattern matching can desconstruct-assign only to local variables, so when using `=>` as an assignment operator, you will see those are syntax errors:
          ```ruby
          some_statement => @x
          some_statement => obj.attr # meaning to call `obj.attr=`
          some_statement => $y # ...though maybe don't use global variables :)
          ```
      followups: |
        * As of 3.1, the feature is no longer experimental;
        * In 3.1, the parenthesis around the pattern became optional

    - title: Pattern matching with `in` as a `true`/`false` check
      kind: addition
      importance: medium
      category: Pattern Matching
      summary: After the change for one-line pattern matching with `=>`, `in` was reintroduced to return `true`/`false` (whether the pattern matches) instead of raising `NoMatchingPatternError`.
      reason: The new meaning allows pattern matching to be more tightly integrated with other constructs in the control flow, like iteration and regular conditions.
      feature: 17371
      docs: https://docs.ruby-lang.org/en/3.0.0/syntax/pattern_matching_rdoc.html
      code: |
        ```ruby
        user = {role: 'admin', login: 'matz'}
        if user in {role: 'admin', login:}
          puts "Granting admin scope: #{login}"
        end
        # otherwise just proceed with regular scope, no need to raise

        users = [
          {name: 'John', role: 'user'},
          {name: 'Jane', registered_at: Time.new(2017, 5, 8) },
          {name: 'Barb', role: 'admin'},
          {name: 'Dave', role: 'user'}
        ]
        old_users_range = Time.new(2016)..Time.new(2019)
        # Choose for some notification only admins and old users
        users.select { |u| u in {role: 'admin'} | {registered_at: ^old_users_range} }
        #=> [{:name=>"Jane", :registered_at=>2017-05-08 00:00:00 +0300}, {:name=>"Barb", :role=>"admin"}]
        ```
      notes: |
        * Feature is marked as EXPERIMENTAL, will warn so on an attempt of usage, and may change in the future.
      followups: |
        * As of 3.1, the feature is no longer experimental;
        * In 3.1, the parenthesis around the pattern became optional

    - title: Find patterns
      kind: addition
      importance: medium
      category: Pattern Matching
      summary: Pattern matching now supports "find patterns", with several splats in them.
      feature: 16828
      docs: https://docs.ruby-lang.org/en/3.0.0/syntax/pattern_matching_rdoc.html
      code: |
        ```ruby
        users = [
          {name: 'John', role: 'user'},
          {name: 'Jane', role: 'manager'},
          {name: 'Barb', role: 'admin'},
          {name: 'Dave', role: 'manager'}
        ]

        # Now, how do you find admin with just pattern matching?..

        # Ruby 3.0:
        case users
        in [*, {name:, role: 'admin'}, *] # Note the pattern: find something in the middle, with unknown number of items before/after
          puts "Admin: #{name}"
        end
        # => Admin: Barb

        # Without any limitations to choose the value, the first splat is non-greedy:
        case users
        in [*before, user, *after]
          puts "Before match: #{before}"
          puts "Match: #{user}"
          puts "After match: #{after}"
        end
        # Before match: []
        # Match: {:name=>"John", :role=>"user"}
        # After match: [{:name=>"Jane", :role=>"manager"}, {:name=>"Barb", :role=>"admin"}, {:name=>"Dave", :role=>"manager"}]

        # Guard clause does not considered when choosing where to splat:
        case users
        in [*, user, *] if user[:role] == 'admin'
          puts "User: #{user}"
        end
        # => NoMatchingPatternError -- it first put John into `user`,
        # and only then checked the guard clause, which is not matching

        # If the "find pattern" is used (there is more than one splat in the pattern),
        # there should be exactly TWO of them, and they may ONLY be the very first and
        # the very last element:
        case users
        in [first_user, *, {name:, role: 'admin'}, *]
          #                                        ^  syntax error, unexpected *
          puts "Admin: #{name}"
        end

        # Singular splat is still allowe in any place:
        case users
        in [{name: first_user_name}, *, {name: last_user_name}]
          puts "First user: #{first_user_name}, last user: #{last_user_name}"
        end
        # => First user: John, last user: Dave
        ```
      notes: Feature is marked as EXPERIMENTAL, will warn so on an attempt of usage, and may change in the future.

    - title: Parent classes overwriting class variables raises an error
      kind: change
      importance: medium
      summary: When class `@@variable` is overwritten by the parent of the class, or by the module included, a `RuntimeError` is raised. In addition, top-level class variable access also raises an error.
      reason: Class variables, with their "non-intuitive" access rules, are frequently considered a bad practice. They still can be very useful for tracking something across class hierarchy. But the fact that the entire hierarchy shares the same variable may lead to hard-to-debug bugs, so it was fixed to raise on the usage that seems unintentional.
      bug: 14541
      code: |
        ```ruby
        # Intended usage: parent defines the variable available for all children
        class Good
          @@registry = [] # assume it is meant to store all the children

          def self.registry
            @@registry
          end
        end

        class GoodChild < Good
          def self.register!
            @@registry << self
            @@registry = @@registry.sort # reassigning the value -- but it is still the PARENT's variable
          end
        end

        GoodChild.register!
        p Good.registry # => [GoodChild]

        # Unintended usage: the variable is defined in the child, but then the parent changes it
        class Bad
          def self.corrupt_registry!
            @@registry = []
          end
        end

        class BadChild < Bad
          @@registry = {} # This is some variable which meant to belong to THIS class

          def self.registry
            @@registry
          end
        end

        Bad.corrupt_registry! # Probably unexpected for BadChild's author, its ancestor have changed the variable
        BadChild.registry     # On the next attempt to _access_ the variable the error will be raised
        # 2.7: => []
        # 3.0: RuntimeError (class variable @@registry of BadChild is overtaken by Bad)

        # The same error is raised if the included module suddenly changes class
        module OtherRegistry
          @@registry = {}
        end

        Good.include OtherRegistry
        Good.registry      # On the next attempt to _access_ the variable the error will be raised
        # 2.7: => {}
        # 3.0: RuntimeError (class variable @@registry of Good is overtaken by OtherRegistry)
        ```
      class: Class

    - title: "`$SAFE` and `$KCODE` no longer have any meaning"
      kind: removal
      importance: low
      summary: |
        * `$SAFE`, the global setting related to tainting, was deprecated in 2.7.
        * `$KCODE` also no longer holds any special behavior
      feature: [16131, 17136]

    - title: "`yield` inside a singleton class block now raises an error"
      kind: removal
      importance: low
      summary: This was deprecated in 2.7, and now results in a `SyntaxError` if present
      feature: 15575

    - title: Assigning to a numbered block parameter results in a `SyntaxError`
      kind: change
      importance: medium
      summary: Numbered block parameters were introduced in 2.7, and back then raised a warning when you assigned a value to them. Assignment now results in a `SyntaxError`.
      code: |
        ```ruby
        [1,2,3].each{ _1 = "somevalue" }
        #=> In Ruby 2.7:
        #=> warning: `_1' is reserved for numbered parameter; consider another name

        #=> In Ruby 3.0:
        #=> _1 is reserved for numbered parameter (SyntaxError)
        ```

    - title: Type declarations in separate files
      kind: addition
      importance: high
      highlight: true
      summary: Type declarations belong in `*.rbs` files, with separate tools for validating.
      reason: |
        The discussion of possible solutions for _static_ or _gradual_ typing and possible syntax of type declarations in Ruby code had been open for years. At 3.0, Ruby's core team made their mind towards **type declaration in separate files** and **separate tools to check types**. So, as of 3.0:

        * **type declarations** for Ruby code should be defined **in separate files** with extension `*.rbs`
        * **the syntax for type declarations** is like following (small example):
          ```ruby
          class Dog
            attr_reader name: String

            def initialize: (name: String) -> void

            def bark: (at: Person | Dog | nil) -> String
          end
          ```
        * **type declaration for the core classes and the standard library** is shipped with the language;
        * **[rbs](https://github.com/ruby/rbs) library is shipped with Ruby**, providing tools for checking actual types in code against the declarations; and for auto-detecting (to some extent) the actual types of yet-untyped code;
        * **[TypeProf](https://github.com/ruby/typeprof)** is another tool ("Type Profiler") shipping with Ruby 3.0 as a bundled gem, allowing **to auto-detect the actual types** of the Ruby by "abstract interpretation" (running through code without actually executing it);

        For a deeper understanding, please check those tools' documentation; also [this article](https://evilmartians.com/chronicles/climbing-steep-hills-or-adopting-ruby-types) by Vladimir Dementiev of Evil Martians takes a detailed look into tools and concepts.

  Core Classes and Modules:
    - title: "`Object#clone(freeze:true)`"
      kind: addition
      importance: low
      summary: |
        `freeze:` argument now works both ways (previously only `freeze: false` had an effect).

      reason: |
        Mostly for consistency. `Object#clone(freeze: false)` was [introduced in Ruby 2.4](2.4.html#objectclonefreeze-false) as an _only_ way of producing unfrozen object; `clone(freeze: true)` is basically an equivalent of `clone` + `freeze`.
      feature: 16175
      docs: https://docs.ruby-lang.org/en/3.0.0/Kernel.html#method-i-clone
      code: |
        ```ruby
        o = Object.new
        o.clone(freeze: true).frozen?
        # => false in Ruby 2.7
        # => true in Ruby 3.0

        o = Object.new.freeze
        o.clone(freeze: false).frozen?
        # => false in Ruby 2.7 and 3.0
        ```
      class: Kernel

    - title: "`Object#clone` passes `freeze:` argument to `#initialize_clone`"
      kind: addition
      importance: low
      summary: Specialized constructor `#initialize_clone`, which is called when object is cloned, now receives `freeze:` argument if it was passed to `#clone`.
      reason: For composite objects, it is hard to address freezing/unfreezing of nested data in `#initialize_clone` without this argument.
      bug: 14266
      docs: https://docs.ruby-lang.org/en/3.0.0/Kernel.html#method-i-clone)
      code: |
        ```ruby
        require 'set'
        set = Set[1, 2, 3].freeze
        set.frozen? # => true
        set.instance_variable_get('@hash').frozen? # => true, as expected

        unfrozen = set.clone(freeze: false)
        unfrozen.frozen? # => false, as expected
        unfrozen.instance_variable_get('@hash').frozen?
        # 2.7: => true, still
        # 3.0: => false, as it should be -- becase Set have redefined #initialize_clone

        unfrozen << 4
        # 2.7: FrozenError (can't modify frozen Hash: {1=>true, 2=>true, 3=>true})
        # 3.0: => #<Set: {1, 2, 3, 4}>
        ```
      notes: A lot of attention to proper object freezing in Ruby 3.0 is due to the introduction of Ractors, which made the important distinction if the object is truly frozen (and therefore safe to share between parallel ractors).

    - title: "`Kernel#eval` changed processing of `__FILE__` and `__LINE__`"
      kind: change
      importance: low
      summary: Now, when the second argument (`binding`) is passed to `eval`, `__FILE__` in evaluated code is `(eval)`, and `__LINE__` starts from `1` (just like without `binding`). Before 2.7 it was evaluated in context of `binding` (e.g. returned file from where `binding` came from), on 2.7 the warning was printed; now the behavior is considered final.
      reason: Binding might be passed to `eval` in order to provide the access to some context necessary for evaluation (this technique, for example, frequently used in templating engines); but it had an unintended consequence of making `__FILE__` and `__LINE__` to point not to actually evaluated code, which can be misleading, for example, on errors processing.
      bug: 4352
      docs:
        - https://docs.ruby-lang.org/en/3.0.0/Kernel.html#method-i-eval
        - https://docs.ruby-lang.org/en/3.0.0/Binding.html#method-i-eval
      code: |
        ```ruby
        # file a.rb
        class A
          def get_binding
            binding
          end
        end

        # file b.rb
        require_relative 'a'
        eval('p [__FILE__, __LINE__]')                    # without binding
        eval('p [__FILE__, __LINE__]', A.new.get_binding) # with binding from another file
        # Ruby 2.6:
        #  ["(eval)", 1]
        #  ["a.rb", 3]

        # Ruby 2.7:
        #  ["(eval)", 1]
        #  ["a.rb", 3]
        #   warning: __FILE__ in eval may not return location in binding; use Binding#source_location instead
        #   warning: __LINE__ in eval may not return location in binding; use Binding#source_location instead

        # Ruby 3.0:
        #  ["(eval)", 1]
        #  ["(eval)", 1]
        ```
      class: Kernel

    - title: "`Regexp` and `Range` objects are frozen"
      kind: change
      importance: low
      reason: |
        The change is related to Ractor introduction (see below): it makes a difference whether an object is frozen when sharing it between ractors. As both ranges and regexps have immutable core data, it was considered that making them frozen is the right thing to do.
      feature: 8948
      code: |
        ```ruby
        /foo/.frozen?   # => true
        (42...).frozen? # => true

        # Regexps are frozen even when constructed with dynamic interpolation
        /.#{rand(10)}/.frozen? # => true

        # ...but not when they are constructed with the constructor
        Regexp.new('foo').frozen?  # => false

        # ...but ranges are always frozen
        Range.new('a', 'b').frozen? # => true

        # Regularly, as the data can't be changed anyways, the frozenness wouldn't affect your code.
        # It might, though, if the code does something smart like:
        regexp = /^\w+\s*\w*$/
        regexp.instance_variable_set('@context', :name)
        # 2.7: ok
        # 3.0: FrozenError (can't modify frozen Regexp: /^\w+\s*\w*$/)

        # ...or
        RANGE = Time.new(2020, 3, 1)..Time.new(2020, 9, 1)
        def RANGE.to_s
          self.begin.strftime('%Y, %b %d') + ' - ' + self.end.strftime('%b %d')
        end
        # 2.7: OK
        # 3.0: FrozenError (can't modify frozen object: 2020-03-01 00:00:00 +0200..2020-09-01 00:00:00 +0300)

        # Note also, that range freezing is not "deep":
        string_range = 'a'..'z'
        string_range.end.upcase!
        string_range
        # => 'a'..'Z'

        # clone(freeze: false) still allows to unfreeze both:
        unfrozen = RANGE.clone(freeze: false)
        def unfrozen.to_s
          self.begin.strftime('%Y, %b %d') + ' - ' + self.end.strftime('%b %d')
        end
        puts unfrozen
        # Prints: "2020, Mar 01 - Sep 01"
        ```
      notes: |
        The fact that dynamically created ranges are frozen and regexps are not, is explained this way: Ideally, both should be frozen, yet there are some gems (and some core Ruby tests) that use dynamic singleton method definitions on regexps, and it was decided that incompatibility should be avoided.

    - title: "`#include` and `#prepend` now affect modules including the receiver"
      kind: change
      importance: medium
      category: Module
      summary: If class `C` includes module `M`, and after that we did `M.include M1`, before Ruby 3.0, `M1` would not have been included into `C`; and now it is.
      reason: The behavior was long-standing and led to a lot of confusion (especially considering that including something in the class _did_ affected its descendants).
      feature: 9573
      code: |
        ```ruby
        module MyEnumerableExtension
          def each2(&block)
            each_slice(2, &block)
          end
        end

        Enumerable.include MyEnumerableExtension

        (1..8).each2.to_a
        # Ruby 2.7: NoMethodError (undefined method `each2' for 1..8:Range) -- even though Range includes Enumerable
        # Ruby 3.0: [[1, 2], [3, 4], [5, 6], [7, 8]]
        ```
      followups: In Ruby 3.1, `#prepend` behavior was adjusted further to be more predictable.
      class: Module

    - title: "Improved method visibility declaration"
      kind: change
      importance: medium
      category: Module
      summary: |
        * `private attr_reader :a, :b, :c` and `private alias_method :foo, :bar` now work exactly like one might expect.
        * `Module#public`, `#private`, `#protected` can now accept an array. While it is not necessary when a literal list of symbols is passed, it is more convenient when the method names are calculated by some DSL method.
        * `Module#attr_accessor`, `#attr_reader`, `#attr_writer` now return arrays of symbols with new methods names defined.
        * `Module#alias_method` now returns a name of the method defined.
      docs:
        - https://docs.ruby-lang.org/en/3.0.0/Module.html#method-i-private
        - https://docs.ruby-lang.org/en/3.0.0/Module.html#method-i-public
        - https://docs.ruby-lang.org/en/3.0.0/Module.html#method-i-protected
        - https://docs.ruby-lang.org/en/3.0.0/Module.html#method-i-public_class_emethod
        - https://docs.ruby-lang.org/en/3.0.0/Module.html#method-i-private_class_method
        - https://docs.ruby-lang.org/en/3.0.0/Module.html#method-i-attr
        - https://docs.ruby-lang.org/en/3.0.0/Module.html#method-i-attr_reader
        - https://docs.ruby-lang.org/en/3.0.0/Module.html#method-i-attr_writer
        - https://docs.ruby-lang.org/en/3.0.0/Module.html#method-i-attr_accessor
        - https://docs.ruby-lang.org/en/3.0.0/Module.html#method-i-alias_method
      feature: 17314
      code: |
        ```ruby
        class A
          def foo
          end

          def bar
          end

          # new behavior of private
          private %i[foo bar]
          # Ruby 2.7: [:foo, :bar] is not a symbol nor a string
          # Ruby 3.0: works

          # old behavior still works
          private :foo, :bar

          # new behavior of attr_XX
          p(attr_reader :a, :b)
          # Ruby 2.7: => nil
          # Ruby 3.0: => [:a, :b]

          # new behavior of alias_method
          p(alias_method :baz, :foo)
          # Ruby 2.7: => A
          # Ruby 3.0: => :bar

          # The consequence is this is now possible:
          private attr_reader :first, :second
          # attr_reader() returns array [:first, :second], which is then passed to private()

          private alias_method :third, :second
          # alias_method() returns :third, which is then passed to private()
        end
        ```
      notes: |
        Unlike `alias_method`, `alias` is not a method but a language construct, and its behavior haven't changed (and it can't be used in an expression context):

        ```ruby
        class A
          def foo
          end

          private alias bar foo
          #       ^ syntax error, unexpected `alias'
        end
        ```
      followups: In Ruby 3.1, `#private`, `#protected`, `#public`, and `#module_function` return their arguments for better macros chainability.
      class: Module

    - title: "`Warning#warn` gains `category:` argument."
      kind: addition
      importance: low
      summary: Ruby 2.7 introduced warning categories, and allowed to selectively suppress them with `Warning[]=` method. Since Ruby 3.0, user code also may specify categories for its warnings, and intercept them by redefining `Warning.warn`.
      feature: 17122
      docs:
        - https://docs.ruby-lang.org/en/3.0.0/Warning.html#method-i-warn
        - https://docs.ruby-lang.org/en/3.0.0/Kernel.html#method-i-warn
      code: |
        ```ruby
        # Using from user code:
        Warning[:deprecated] = true
        warn('my warning', category: :deprecated)
        # "my warning"
        Warning[:deprecated] = false
        warn('my warning', category: :deprecated)
        # ...nothing, obeys "don't show deprecated" setting

        # If the category is not supported:
        warn('my warning', category: :custom)
        # ArgumentError (invalid warning category used: custom)

        # Intercepting:
        module Warning
          def self.warn(msg, category: nil)
            puts "Received message #{msg.strip} with category=#{category}"
          end
        end

        Warning[:deprecated] = true
        lambda(&:foo?)
        # Received message 'warn.rb:23: warning: lambda without a literal block is deprecated; use the proc without lambda instead' with category=deprecated

        eval('[1, 2, 3] => [x, *]') # we use eval, otherwise the warning was raised on PARSING stage, before any redefinitions
        # Received message '(eval):1: warning: One-line pattern matching is experimental, and the behavior may change in future versions of Ruby!' with category=experimental
        ```
      class: Warning

    - title: "Exception output order is changed (again)"
      kind: change
      importance: medium
      summary: The "reverse" order of the backtrace (call stack printed starting from the outermost layer, and the innermost is at the bottom), which was introduced in 2.5 as "experimental" and tweaked to be active only for `STDERR` on 2.6, has now reverted to the old (pre-2.5) behavior.
      reason: |
        "From the outer to the inner" order is the default for some other languages (like Python), but it seems most of the rubyists never got used to it.
      feature: 8661
      code: |
        ```ruby
        def inner
          raise 'test'
        end

        def outer
          inner
        end

        outer
        ```
        This prints on Ruby 2.5-2.7:
        ```
        Traceback (most recent call last):
          2: from test.rb:9:in `<main>'
          1: from test.rb:6:in `outer'
        test.rb:2:in `inner': test (RuntimeError)
        ```
        But on Ruby < 2.5, and on 3.0 again:
        ```
        test.rb:2:in `inner': test (RuntimeError)
          from test.rb:6:in `outer'
          from test.rb:9:in `<main>'
        ```
      notes: |
        While redesigning the backtrace, command-line option `--backtrace-limit=<number-of-entries>` was introduced, so, you can run the example above this way to partially suppress backtrace:

        ```
        $ ruby --backtrace-limit=0 test.rb
        test.rb:2:in `inner': test (RuntimeError)
          ... 2 levels...
        ```
      class: (ruby)

    - title: "Interpolated String literals are no longer frozen when `#frozen-string-literal: true` is used"
      kind: change
      importance: low
      category: Strings and symbols
      reason: The idea of `frozen-string-literal` pragma is to avoid unnecessary allocations, when the same `"string"` repeated in the code called multiple times; but if the string is constructed dynamically with interpolation, there would be no point (it is hard to predict that allocations would be avoided, as the string can be different each time; it also breaks the "intuitive" feeling that the string is dynamic.
      feature: 17104
      docs: https://docs.ruby-lang.org/en/3.0.0/syntax/comments_rdoc.html#label-frozen_string_literal+Directive
      code: |
        ```ruby
        # frozen-string-literal: true

        def render(title, body)
          result = "## #{title}"
          result << "\n"
          result << body
        end

        puts render('The Title', 'The body')
        # Ruby 2.7: in `render': can't modify frozen String (FrozenError)
        # Ruby 3.0:
        #   ## The Title
        #   The body
        ```
      class: String

    - title: Methods on subclasses of `String` always return `String` instances
      kind: change
      importance: low
      category: Strings and symbols
      summary: On custom classes inherited from `String`, some methods previously were returning an instance of this class, and others returned `String`. Now they all do the latter.
      reason: |
        While one might argue that `MyCoolString.new(" foo ").strip` should return an instance of `MyCoolString`, it actually creates a significant problem: String internals don't know how to construct a new instance of the child class (imagine it has a constructor like `StringFromFile.new(content, filename:)`), and in Ruby versions before 3.0 they didn't actually construct child classes with the constructor. It was a source of all kinds of subtle bugs.

        **Affected methods:** `#*`, `#capitalize`, `#center`, `#chomp`, `#chop`, `#delete`, `#delete_prefix`, `#delete_suffix`, `#downcase`, `#dump`, `#each_char`, `#each_grapheme_cluster`, `#each_line`, `#gsub`, `#ljust`, `#lstrip`, `#partition`, `#reverse`, `#rjust`, `#rpartition`, `#rstrip`, `#scrub`, `#slice!`, `#slice` / `#[]`, `#split`, `#squeeze`, `#strip`, `#sub`, `#succ` / `#next`, `#swapcase`, `#tr`, `#tr_s`, `#upcase`
      bug: 10845
      code: |
        ```ruby
        class Buffer < String
          attr_reader :capacity

          def initialize(content, capacity:)
            super(content)
            @capacity = capacity
          end

          # some impl.
        end

        stripped = Buffer.new(' foo ', capacity: 100).strip
        stripped.class
        # Ruby 2.7: Buffer
        # Ruby 3.0: String
        stripped.capacity
        # Ruby 2.7: nil -- one might ask "why it haven't been copied from parent???"
        # Ruby 3.0: NoMethodError (undefined method `capacity' for "foo":String)
        ```
      notes: A similar change was implemented for Array.
      class: String

    - title: "`Symbol#name` added"
      kind: addition
      importance: low
      category: Strings and symbols
      summary: The method returns a frozen string with the symbol's representation.
      reason: |
        Producing non-frozen strings from `Symbol#to_s` might lead to a memory/performance overhead, for example, when large data structures are serialized. It was discussed that `#to_s` should be changed to just return a frozen String, but it would create a backward compatibility problem in code looking like this:

        ```ruby
        # Not the best, but existing in the wild way of constructing strings from data containing symbols
        {some: 'data'}.map { |k, v| k.to_s << ': ' << v }.join(', ')
        # If k.to_s returns a frozen string, it would throw FrozenError (can't modify frozen String: "some")
        ```

        As a compromise, this new method was added.
      feature: 16150
      docs: https://docs.ruby-lang.org/en/3.0.0/Symbol.html#method-i-name
      class: Symbol

    - title: Methods on subclasses of `Array` always return `Array` instances
      kind: change
      importance: low
      category: Collections
      summary: |
        On custom classes inherited from `Array`, some methods previously were returning an instance of this class, and others returned `Array`. Now they all do the latter.

        * **Affected methods:** `#*`, `#drop`, `#drop_while`, `#flatten`, `#slice!`, `#slice` / `#[]`, `#take`, `#take_while`, `#uniq`
      reason: See reason frr similar change to `String` from this release.
      bug: 6087
      code: |
        ```ruby
        class Nodes < Array
          attr_reader :parent
          def initialize(nodes, parent)
            super(nodes)
            @parent = parent
          end

          # some impl.
        end

        uniq = Nodes.new(['<tr>Name</tr>', '<tr>Position</tr>', '<tr>Name</tr>'], 'table').uniq
        uniq.class
        # Ruby 2.7: Nodes
        # Ruby 3.0: Array
        uniq.parent
        # Ruby 2.7: nil -- one might ask "why it haven't been copied from parent???"
        # Ruby 3.0: NoMethodError (undefined method `uniq' for ["<tr>Name</tr>", "<tr>Position</tr>"]:Array)
        ```
      class: Array

    - title: "`Array#[]` and `#slice` accept `Enumerator::ArithmeticSequence`"
      kind: addition
      importance: medium
      category: Collections
      summary: |
        `Enumerator::ArithmeticSequence` was introduced in 2.6 as an concept representing "sequence from `b` to `e` with step `s`". Since 3.0, `Array#[]` and `Array#slice` accept arithmetic sequence as a slicing argument.
      feature: 16812
      docs: https://docs.ruby-lang.org/en/3.0.0/Array.html#method-i-5B-5D
      code: |
        ```ruby
        text_data = ['---', 'Jane', '---', 'John', '---', 'Yatsuke', '---']
        text_data[(1..) % 2] # each second element
        # => ["Jane", "John", "Yatsuke"]

        # Note that unlike slicing with Range, slicing with ArithmeticSequence might raise RangeError:
        text_data[0..100]
        # => ["---", "Jane", "---", "John", "---", "Yatsuke", "---"]
        text_data[(0..100) % 2]
        # RangeError (((0..100).%(2)) out of range)
        ```
      notes: |
        Don't forget to put `()` around range: without them, `0..100 % 2` is actually `(0)..(100 % 2)`, e.g. `0..0`.
      class: Array

    - title: "`Hash#except` added"
      kind: addition
      importance: medium
      category: Collections
      reason: |
        `Hash#slice` ("only selected set of keys") was added in Ruby 2.5, but `Hash#except` was missing at this point. Added for completeness, and because it has lot of pragmatic usages.
      feature: 15822
      docs:
        - https://docs.ruby-lang.org/en/3.0.0/Hash.html#method-i-except
        - https://docs.ruby-lang.org/en/3.0.0/ENV.html#method-c-except
      code: |
        ```ruby
        h = {a: 1, b: 2}
        h.except(:b)
        # => {:a=>1}
        h.except(:c)        # unknown key is not an error
        # => {:a=>1, :b=>2}
        ```
      notes: Unlike ActiveSupport, there's no `Hash#except!` (like there is no `#slice!`)
      class: Hash

    - title: "`Hash#transform_keys` accepts Hash map"
      kind: addition
      importance: medium
      category: Collections
      summary: "`Hash#transform_keys(from: to)` allows to rename keys in a DRY way."
      feature: 16274
      docs: https://docs.ruby-lang.org/en/3.0.0/Hash.html#method-i-transform_keys
      code: |
        ```ruby
        h = {name: 'Ruby', years: 25}
        h.transform_keys(name: :title, years: :age)
        # => {:title=>"Ruby", :age=>25}
        h.transform_keys(name: :title, site: :url)
        # => {:title=>"Ruby", :years=>25} -- not mentioned keys are copied as is, unknown keys ignored
        h.transform_keys(years: :name, name: :title)
        # => {:title=>"Ruby", :name=>25} -- note that the first rename wouldn't replace the :name key, because
        #                                   first all renames are deduced, and then applied
        h.transform_keys(name: :lang_name) { |k| :"meta_#{k}" }
        # => {:lang_name=>"Ruby", :meta_years=>25} -- block, if passed, is used to process keys the hash doesn't mention

        h.transform_keys!(name: :title, years: :age) # bang version works, too
        h
        # => {:title=>"Ruby", :age=>25}
        ```
      class: Hash

    - title: "`Hash#each` consistently yields a 2-element array to lambdas"
      kind: addition
      importance: low
      category: Collections
      summary: Just fixes an inconsistency introduced by optimization many versions ago.
      bug: 12706
      code: |
        ```ruby
        {a: 1}.each(&->(pair) { puts "pair=#{pair}" })
        # 2.7 and 3.0: pair=[:a, 1] -- so, it is "yield 2 items as one argument"
        {a: 1}.each(&->(pair, redundant) { puts "pair=#{pair}, redudnant=#{redundant}" })
        # 2.7: pair=a, redudnant=1 -- arguments accidentally behave like for regular proc (auto-unpacking)
        # 3.0: ArgumentError (wrong number of arguments (given 1, expected 2)) -- no unexpected auto-unpacking
        ```
      class: Hash

    - title: "`Symbol#to_proc` identifies as lambda"
      kind: change
      importance: low
      category: Procs/lambdas
      reason: It was noted that the result of `&:something` behaves like a lambda, but its introspection methods are misleadingly reported it as a regular proc. While no big offense, it can be inconvenient when learning, and produce subtle bugs in complicated metaprogramming.
      feature: 16260
      code: |
        ```ruby
        def test_it(&block)
          p [block.lambda?, block.parameters]
        end

        # Regular proc
        test_it { |x| x.size }      # => [false, [[:opt, :x]]]
        # Regular lambda
        test_it(&->(x) { x.size })  # => [true, [[:req, :x]]]
        # Symbol proc
        test_it(&:size)
        # Ruby 2.7: [false, [[:rest]]]
        # Ruby 3.0: [true, [[:req], [:rest]]]
        ```

        The second one is more true, because it behaves like lambda: doesn't auto-unpack parameters, and
        requires the first one:

        ```ruby
        Warning[:deprecated] = true
        proc { |x, y| x + y }.call([1, 2])    # => 3, parameters unpacked
        proc { |x| x.inspect }.call           # => "nil", no error, parameter is optional
        lambda { |x, y| x + y }.call([1, 2])  # ArgumentError (wrong number of arguments (given 1, expected 2))
        lambda { |x| x.inspect }.call         # ArgumentError (wrong number of arguments (given 0, expected 1))
        :+.to_proc.call([1, 2])               # ArgumentError (wrong number of arguments (given 0, expected 1))
        :inspect.to_proc.call                 # ArgumentError (no receiver given)
        ```

        Note that the last two errors was raised even on Ruby 2.7, so the behavior is not changed, just introspection made consistent.
      class: Proc

    - title: "`Kernel#lambda` warns if called without a literal block"
      kind: change
      importance: low
      category: Procs/lambdas
      reason: One might expect that `lambda(&other_block)` will change block's "lambdiness". It is not true, and it was decided that this behavior shouldn't change. Instead, to avoid errors, this code now warns.
      feature: 15973
      code: |
        ```ruby
        block = proc { |x| p x }
        processed = lambda(&block)
        # On 3.0: warning: lambda without a literal block is deprecated; use the proc without lambda instead
        processed.lambda? # => false
        processed.call    # => "nil", it is really still not a lambda
        ```
      class: Kernel

    - title: "`Proc#==` and `#eql?` fixed for procs from the same block"
      kind: change
      importance: low
      category: Procs/lambdas
      summary: The method will return true for separate Proc instances if the procs were created from the same block.
      reason: Lazy Proc allocation optimization (not creating `Proc` object while just propagating `&block` further) introduced an inconvenience for some DSL libraries when what are "logically" two references to the same proc, would become two unrelated objects, which could lead to subtle bugs.
      feature: 14267
      docs: https://docs.ruby-lang.org/en/3.0.0/Proc.html#method-i-3D-3D
      code: |
        ```ruby
        class SomeDSL
          attr_reader :before_block, :after_block

          def before(&block)
            @before_block = block
          end

          def after(&block)
            @after_block = block
          end

          def before_and_after(&block)
            before(&block)
            after(&block)
          end

          def before_and_after_are_same?
            @before_block == @after_block
          end
        end

        dsl = SomeDSL.new
        dsl.before_and_after { 'some code' }
        dsl.before_block.object_id == dsl.after_block.object_id
        # => true on Ruby 2.4: they were converted to Proc object in #before_and_after, and then this
        #    object was propagated to #before/#after
        # => false on Ruby 2.5-3.0: block was propagated without converting to object, and converts to
        #    two different objects in #before/#after while storing in variables
        p dsl.before_and_after_are_same?
        # => true on Ruby 2.4, because it is the same object
        # => false on Ruby 2.5-2.7
        # => true on 3.0: the objects ARE different, but == implemented the way that they are equal if
        #    they are produced from exactly the same block
        ```
      class: Proc

    - title: "`Random::DEFAULT` changed to Random"
      kind: change
      importance: low
      summary: |
        `Random::DEFAULT` was an instance of the `Random` class, used by `Random.rand`/`Kernel.rand`. The object was removed, and now `Random::DEFAULT` is just an alias for `Random` class itself (it has class-level methods same as instance-level methods), and `Random.rand` creates a new random generator implicitly _per ractor_, on the first call in that ractor.

      reason: With the introduction of the Ractors, global mutable objects can't be used, and `Random::DEFAULT` was such object (its state have changed with each `#rand` call); so now the default random generator is ractor-local, and is not exposed as a constant (it is decided that it would be too confusing to have a constant with the value different in each ractor).
      feature: 17322
      docs: https://docs.ruby-lang.org/en/3.0.0/Random.html
      code: |
        ```ruby
        Warning[:deprecated] = true
        Random::DEFAULT
        # Ruby 2.7: => #<Random:0x005587d09fba20>
        # Ruby 3.0:
        #   warning: constant Random::DEFAULT is deprecated
        #   => Random -- just the same class

        Random.seed
        # Ruby 2.7: NoMethodError: undefined method `seed' for Random:Class
        # Ruby 3.0: => 77406376310392739943146667089721213130

        # Seed is delegated to (now internal) per-Ractor random object, which is always the same in the same ractor
        10.times.map { Random.seed }.uniq
        # => [77406376310392739943146667089721213130]

        # It is different in another ractor
        Ractor.new { p Random.seed }
        # => 95097031741178961937025250800360539515
        ```
      notes: |
        See Ractors change and [Ractor](https://docs.ruby-lang.org/en/3.0.0/Ractor.html) class docs for deeper understanding of ractors data sharing model.
      class: Random

    - title: "`Dir.glob` and `Dir.[]` results now sorted"
      kind: change
      importance: medium
      summary: By default the results are sorted, which can be turned off with `sorted:false`
      reason: |
        `Dir.glob` historically returns the results in the same order the underlying OS API does it (which is undefined on Linux). While it can be argued as "natural" (do what the OS does), it is inconvenient for most of the cases; and most of other languages and tools switched to sorting in the last years.
      feature: 8709
      docs: https://docs.ruby-lang.org/en/3.0.0/Dir.html#method-c-glob
      notes: |
        `Dir.glob('pattern', sort: false)` allows to return results in old (system) order; this might be useful when testing some OS behavior.
      class: Dir

    - title: "Ractors"
      kind: addition
      importance: high
      category: Concurrency
      summary: |
        A long-anticipated concurrency improvement landed in Ruby 3.0. **Ractors** (at some point known as _Guilds_) are fully-isolated (without sharing GVL on CRuby) alternative to threads. To achieve thread-safety without global locking, ractors, in general, can't access each other's (or main program/main ractor) data. To share data with each other, ractors rely on message passing/receiving mechanism, aka actor model (hence the name). The feature was in design and implementation for a long time, so we'll not try to discuss it here in details or link to some "main" discussion, just provide a simple example and links for further investigation.
      code: |
        The simplistic example of ractors in action (classic "server-client" ping-pong):

        ```ruby
        server = Ractor.new do
          puts "Server starts: #{self.inspect}"
          puts "Server sends: ping"
          Ractor.yield 'ping'                       # The server doesn't know the receiver and sends to whoever interested
          received = Ractor.receive                 # The server doesn't know the sender and receives from whoever sent
          puts "Server received: #{received}"
        end

        client = Ractor.new(server) do |srv|        # The server ractor is passed to client, and available as srv
          puts "Client starts: #{self.inspect}"
          received = srv.take                       # The Client takes a message specifically from the server
          puts "Client received from " \
              "#{srv.inspect}: #{received}"
          puts "Client sends to " \
              "#{srv.inspect}: pong"
          srv.send 'pong'                           # The client sends a message specifically to the server
        end

        [client, server].each(&:take)               # Wait till they both finish
        ```

        This will output:

        ```
        Server starts: #<Ractor:#2 test.rb:1 running>
        Server sends: ping
        Client starts: #<Ractor:#3 test.rb:8 running>
        Client received from #<Ractor:#2 rac.rb:1 blocking>: ping
        Client sends to #<Ractor:#2 rac.rb:1 blocking>: pong
        Server received: pong
        ```
      docs:
        - https://docs.ruby-lang.org/en/3.0.0/Ractor.html
        - https://docs.ruby-lang.org/en/3.0.0/doc/ractor_md.html
      followups: In Ruby 3.1, ractor's concept of what's allowed to share was adjusted to include shareable class/module instance variables. Ractors are still considered experimental though.
      class: Ractor

    - title: "Non-blocking `Fiber` and scheduler"
      kind: addition
      importance: medium
      category: Concurrency
      feature: 16786
      summary: |
        The improvement of inter-thread concurrency for IO-heavy tasks is achieved with **non-blocking Fibers**. When several long I/O operations should be performed, they can be put in separate _non-blocking_ Fibers, and instead of blocking each other while waiting, they would be transferring the control to the fiber that can proceed, while others wait.

        **New and updated methods:**

        * `Fiber`: [Fiber.set_scheduler](https://docs.ruby-lang.org/en/3.0.0/Fiber.html#method-c-set_scheduler), [Fiber.scheduler](https://docs.ruby-lang.org/en/3.0.0/Fiber.html#method-c-scheduler), [Fiber.new](https://docs.ruby-lang.org/en/3.0.0/Fiber.html#method-c-new) `(blocking: true/false)` parameter, [Fiber#blocking?](https://docs.ruby-lang.org/en/3.0.0/Fiber.html#method-i-blocking-3F), [Fiber.blocking?](https://docs.ruby-lang.org/en/3.0.0/Fiber.html#method-c-blocking-3F)
        * Methods invoking scheduler: `Kernel.sleep`, `IO#wait_readable`, `IO#wait_writable`, `IO#read`, `IO#write` and other related methods (e.g. `IO#puts`, `IO#gets`), `Thread#join`, `ConditionVariable#wait`, `Queue#pop`, `SizedQueue#push`;
        * `IO#nonblock?` now defaults to `true`;
        * `Mutex` belongs to `Fiber` rather than `Thread` (can be unlocked from other fiber than the one that locked it).
      docs:
        - https://docs.ruby-lang.org/en/master/Fiber.html#class-Fiber-label-Non-blocking+Fibers
        - https://docs.ruby-lang.org/en/master/Fiber/SchedulerInterface.html
        - https://docs.ruby-lang.org/en/3.0.0/doc/fiber_md.html
      code: |
        ```ruby
        require 'net/http'

        start = Time.now

        Thread.new do # in this thread, we'll have non-blocking fibers
          Fiber.set_scheduler Scheduler.new # see Notes about the scheduler implementation

          %w[2.6 2.7 3.0].each do |version|
            Fiber.schedule do # Runs block of code in a separate Fiber
              t = Time.now
              # Instead of blocking while the response will be ready, the Fiber will invoke scheduler
              # to add itself to the list of waiting fibers and transfer control to other fibers
              Net::HTTP.get('rubyreferences.github.io', "/rubychanges/#{version}.html")
              puts '%s: finished in %.3f' % [version, Time.now - t]
            end
          end
        end.join # At the END of the thread code, Scheduler will be called to dispatch all waiting fibers
                # in a non-blocking manner

        puts 'Total: finished in %.3f' % (Time.now - start)
        # Prints:
        #  2.6: finished in 0.139
        #  2.7: finished in 0.141
        #  3.0: finished in 0.143
        #  Total: finished in 0.146
        ```

        Note that "total" is lower than sum of all fibers execution time: on `HTTP.get`, instead of blocking the whole thread, they were transferring control while waiting, and all three waits are performed in parallel.
      notes: |
        The feature is somewhat unprecedented for Ruby in the fact that **no default Scheduler implementation** is provided. Implementing the Scheduler in a reliable way (probably using some additional non-blocking event loop library) is completely up to the user. Considering that the feature is implemented by [Samuel Williams](https://github.com/ioquatix) of the [Async](https://github.com/socketry/async) fame, the Async gem [utilizes](https://github.com/socketry/async/blob/master/lib/async/scheduler.rb) the new feature since the day of 3.0 release.
      followups: In Ruby 3.1, more scheduler hooks were added to make more core methods support asynchronous execution.
      class: Fiber

    - title: "`Thread.ignore_deadlock` accessor added"
      kind: addition
      importance: low
      category: Concurrency
      summary: Allows disabling the default deadlock detection, allowing the use of signal handlers to break deadlock.
      reason: The change helps with rare condition when Ruby's internal deadlock detector is fooled by external signals.
      bug: 13768
      docs:
        - https://docs.ruby-lang.org/en/3.0.0/Thread.html#method-c-ignore_deadlock-3D
        - https://docs.ruby-lang.org/en/3.0.0/Thread.html#method-c-ignore_deadlock
      code: |
        ```ruby
        queue1 = Queue.new
        queue2 = Queue.new

        trap(:SIGCHLD) { queue1.push 'from SIGCHLD to queue1' }

        Thread.start { Process.spawn("/bin/sleep 1") }
        Thread.start { queue2.push("via Thread to queue2: #{queue1.pop}") }

        Thread.ignore_deadlock = true # <== New feature

        # Here the message would be received when the childprocess will finish, send message to queue1,
        # which then will be caught in the thread and sent to queue2.
        puts queue2.pop
        # Prints: "via Thread to queue2: from SIGCHLD to queue1"
        #
        # But Without the marked line, it will be printed instead:
        #  in `pop': No live threads left. Deadlock? (fatal)
        #  ... description of sleeping threads ...
        ```
      class: Thread

    - title: "`Fiber#backtrace` and `#backtrace_locations` added"
      kind: addition
      importance: medium
      category: Concurrency
      summary: Like similar methods of the `Thread`, provides a locations of the currently executed Fiber code.
      feature: 16815
      docs:
        - https://docs.ruby-lang.org/en/3.0.0/Fiber.html#method-i-backtrace
        - https://docs.ruby-lang.org/en/3.0.0/Fiber.html#method-i-backtrace_locations
      code: |
        ```ruby
        f = Fiber.new { Fiber.yield }
        # When fiber is not yet running, the backtrace is empty
        f.backtrace
        # => []

        # When fiber was resumed, and then yielded control, you can ask about its location
        f.resume
        f.backtrace
        # => ["test.rb:1:in `yield'", "fbr.rb:1:in `block in <main>'"]

        f.backtrace_locations
        # => ["fbr.rb:1:in `yield'", "fbr.rb:1:in `block in <main>'"]
        # Despite looking the same, backtrace_locations are actually instances of Thread::Backtrace::Location
        loc = f.backtrace_locations.first
        loc.label   # => "yield"
        loc.path    # => "test.rb"
        loc.line    # => 1

        # Like Thread.backtrace_locations, the method accepts arguments:
        f.backtrace_locations(1) # start from 1
        # => ["fbr.rb:1:in `block in <main>'"]
        f.backtrace_locations(0, 1) # start from 0, take 1
        # => ["test.rb:1:in `yield'"]
        f.backtrace_locations(0...1) # ranges are acceptable, too
        # => ["test.rb:1:in `yield'"]

        f.resume
        # When the fiber is finished, there is no location
        f.backtrace_locations
        # => nil
        ```
      class: Fiber

    - title: "`Fiber#transfer` limitations reduced"
      kind: change
      importance: medium
      category: Concurrency
      summary: |
        `#transfer` is the method that allows fiber to pass control to other fiber directly, allowing several fibers to control each other, creating arbitrary directed graph of control. Two styles of passing control (`Fiber.yield` / `Fiber#resume` vs `Fiber#transfer` to and from fiber) can't be freely mixed: the way in which fiber lost control should be the same it received the control back. In 2.7, this was implemented by a strict rule: once the fiber received control via `#transfer`, it can _never_ return back to `.yield`/`#resume` style. But in 3.0, better grained set of limitations was designed, so when the Fiber passed control via `#transfer` and then received it back (via `#transfer` in other fiber), it again can `.yield` and be `#resume`d.

      reason: The new design makes the "entry point" fiber of `#transfer` graph accessible from outside the graph.
      bug: 17221
      docs: https://docs.ruby-lang.org/en/3.0.0/Fiber.html#method-i-transfer
      code: |
        ```ruby
        require 'fiber'

        manager = nil # For local var to be visible inside worker block

        # This fiber would be started with transfer
        # It can't yield, and can't be resumed
        worker = Fiber.new { |work|
          puts "Worker: starts"
          puts "Worker: Performed #{work.inspect}, transferring back"
          # Fiber.yield     # this would raise FiberError: attempt to yield on a not resumed fiber
          # manager.resume  # this would raise FiberError: attempt to resume a resumed fiber (double resume)
          manager.transfer(work.capitalize)
        }

        # This fiber would be started with resume
        # It can yield or transfer, and can be transferred
        # back or resumed
        manager = Fiber.new {
          puts "Manager: starts"
          puts "Manager: transferring 'something' to worker"
          result = worker.transfer('something')
          puts "Manager: worker returned #{result.inspect}"
          # worker.resume    # this would raise FiberError: attempt to resume a transferring fiber
          Fiber.yield        # this is OK __since 3.0__, the fiber transferred back and from, now it can yield
          puts "Manager: finished"
        }

        puts "Starting the manager"
        manager.resume
        puts "Resuming the manager"
        # manager.transfer  # this would raise FiberError: attempt to transfer to a yielding fiber
        manager.resume # This is possible __since 3.0__
        ```

        This prints:

        ```
        Starting the manager
        Manager: starts
        Manager: transferring 'something' to worker
        Worker: starts
        Worker: Performed "something", transferring back
        Manager: worker returned "Something"
        Resuming the manager
        Manager: finished
        ```

        Before Ruby 3.0, `manager` Fiber (once it ran the loop of `transfer`s with `worker`), had no way to return control generically, to whatever other Fiber wants to run.
      notes: |
        The full list of the new rules are:

        * Can't `transfer` to the fiber resumed (e.g. at currently running due to receiving control via `resume`, and not `transfer`)
        * Can't `transfer` to the fiber yielding (e.g. the one that run `Fiber.yield` and is waiting to be `resume`d)
        * Can't `resume` the fiber transferred (e.g. once the fiber `transfer` to some other fiber, it can obtain the control back only via `transfer`)
        * Can't `Fiber.yield` from the fiber that was never resumed (e.g. that was started due to `transfer`)
      class: Fiber

    - title: "`GC.auto_compact` accessor added"
      kind: addition
      importance: low
      summary: Setter/getter for the option to run `GC.compact` (introduced in Ruby 2.7) on each major garbage collection. `false` by default.
      feature: 17176
      docs:
        - https://docs.ruby-lang.org/en/3.0.0/GC.html#method-c-auto_compact
        - https://docs.ruby-lang.org/en/3.0.0/GC.html#method-c-auto_compact-3D
      notes: It is noticed by feature authors that currently compaction adds a significant overhead to the garbage collection, so should be tested if that's what you want.

