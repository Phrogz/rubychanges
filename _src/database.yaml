- version: "3.1"
  Language Changes:
    - title: Values in Hash literals and keyword arguments can be omitted
      kind: addition
      highlight: true
      summary: |
        In hash literals and method calls, `x:` is now a shortcut for `x: x`—take hash value from the context, with the same name as a key.
      feature: 14579
      docs:
        - https://docs.ruby-lang.org/en/3.1/syntax/literals_rdoc.html#label-Hash+Literals
        - https://docs.ruby-lang.org/en/3.1/syntax/methods_rdoc.html#label-Keyword+Arguments
        - https://docs.ruby-lang.org/en/3.1/Hash.html
      code: |
        ```ruby
        x, y = 100, 200
        # => [100, 200]
        # In hash literal
        h = {x:, y:}
        # => {:x=>100, :y=>200}

        # In method call
        p(x:, y:)
        # prints: "{:x=>100, :y=>200}"

        # Any context-available names work too, not only local variables:
        C = 'constant'
        # => "constant"
        def m()='method'
        # => :m
        {C:, m:}
        # => {:C=>"constant", :m=>"method"}

        # Undefined names behave like in any other context:
        {z:}
        # => undefined local variable or method `z' (NameError)

        # Dynamic symbols are not supported:
        name = 'x'
        {"#{name}":}
        #          ^
        # syntax error, unexpected '}' (SyntaxError)

        # ...including symbols produced from literal strings:
        {'x':}
        #    ^
        # syntax error, unexpected '}' (SyntaxError)

        TODO: self, if, etc
        ```
      notes: |
        Be aware, that using new feature in a method call without parenthesis might lead to unexpected effect:

        ```ruby
        # Useful "puts-debugging" technique: print variable values with names
        p(x:, y:)

        # ...but if you'll write it this way:
        p x:, y:
        x + y # ... some following code

        # It would be interpreted as this, for backward compatibility:
        p(x:, y: x + y)
        ```

        Therefore, if you use value omission in method calls, **always use parenthesis**!
      followups: |
        It is [still discussed](https://bugs.ruby-lang.org/issues/18396#note-4) whether Ruby should handle the problem above (unexpected continuation) more gracefully. It is possible that the behavior would change in a migration-friendly manner: first, the warning in 3.2 about `key:` at the end of the line; then, in 3.3, next line would be considered a separate statement.
      class: [Hash, Method]

    - title: Inside "endless" method definitions, method calls without parentheses are allowed
      kind: addition
      summary: |
        `def some_method = other_method "bar"` is now allowed, previously it was required to write `other_method("bar")` in the method's body.
      reason: When endless methods were introduced in 3.0, this syntax (named "command syntax" internally) wasn't allowed; but it was not a deliberate decision, and rather a side-effect of a parser complexity. During development of 3.1, the workaround was found to make code more consistent and refactoring from multi-line to single-line methods easier.
      feature: 17398
      docs: https://docs.ruby-lang.org/en/3.1/syntax/methods_rdoc.html
      code: |
        ```ruby
        def log(msg) = puts "#{Time.now}: #{msg}"
        # 3.0: syntax error, unexpected string literal, expecting `do' or '{' or '('
        # 3.1: successfully defined
        ```
      class: Method

    - title: Anonymous block argument
      kind: addition
      highlight: true
      summary: If method uses its block argument only to pass to another method, it can be marked by anonymous `&`.
      reason: |
        The initial proposal for the feature is 6-year old and focused on avoiding intermediate blocks object allocation on block forwarding. It was considered redundant when block forwarding was optimized in Ruby 2.5; but then the core team decided it is actually a nice and unambiguous shortcut for methods that just pass the block further. As bloc argument is frequently called just `block`, the absence of the name doesn't affect readability.
      feature: 11256
      docs: https://docs.ruby-lang.org/en/3.1/syntax/methods_rdoc.html#label-Block+Argument
      code: |
        ```ruby
        def logged_open(filename, &)
          puts "Opening #{filename}..."
          File.open(filename, &)
        end

        logged_open('README.md') { puts _1.read(100) }
        # Prints:
        #  Opening README.md
        #  ...first 100 chars of README.md...

        # Attempt to use `&` inside a method without block parameter is an error:
        def filter(data)= data.select(&)
        # => no anonymous block parameter (SyntaxError)

        # ...and with named block parameter too
        def filter(data, &block)= data.filter(&)
        # => no anonymous block parameter (SyntaxError)

        # If you temporary want to catch a block in the method, `Kernel#proc` will help:
        def filter(data, &)
          block = proc(&)
          p block, block.call(5)
          data.filter(&)
        end
        # => :filter
        filter(1..10, &:odd?)
        # Prints:
        #  #<Proc:0x00007fe9842fa308(&:odd?) (lambda)>
        #  true
        # => [1, 3, 5, 7, 9]
        ```
      class: Method

    - title: One-line pattern matching is no longer experimental
      kind: promotion
      summary: Both versions of one-line pattern matching introduced in 3.0--using `=>` and using `in` as a `true`/`false` check--have been promoted to official language features.
      category: Pattern-matching

    - title: Expressions and non-local variables allowed in pin operator `^`
      kind: addition
      highlight: true
      category: Pattern-matching
      summary: On the initial implementation of the pattern matching, the only patterns that could be used in matching expression were constants, literals and pinned local variables. Since 3.1, any kind of statement can be a pattern, with extended functionality of the `^` pin operator.
      feature: [17411, 17724]
      docs: https://docs.ruby-lang.org/en/3.1/syntax/pattern_matching_rdoc.html#label-Variable+pinning
      code: |
        ```ruby
        # In Ruby 3.0, this was possible:
        {version: 12} in {version: 10..15} # range literal as a pattern
        # => true

        # But this was not, despite being intuitively similar:
        {timestamp: Time.now} in {timestamp: (Time.new(2021)..Time.new(2022))}
        # syntax error

        # In 3.1, this is possible with pinning:
        {timestamp: Time.now} in {timestamp: ^(Time.new(2021)..Time.new(2022))}
        # => true

        # Any complex expression is possible
        # ...consider years.txt has lines like "2021-2025", some ranges of years.
        Time.now.year in ^(File.read('years.txt').lines.first.then { _1.split('-') }.then { _1.to_i.._2.to_i })

        # parenthesis are mandatory, this wouldn't work:
        Time.now.year in ^rand(2021..2023)
        # syntax error
        ```

    - title: Parentheses can be omitted in one-line pattern matching
      kind: addition
      category: Pattern-matching
      feature: 16182
      docs: https://docs.ruby-lang.org/en/3.1/syntax/pattern_matching_rdoc.html#label-Patterns
      code: |
        ```ruby
        [0, 1] => _, x
        # 3.0:
        #   syntax error, unexpected ',', expecting `end'
        #   [0, 1] => _, x
        #              ^
        # 3.1: success:
        x #=> 1

        {y: 2} => y:
        # 3.0
        #   syntax error, unexpected label)
        #   {y: 2} => y:
        #             ^~
        # 3.1: success:
        y #=> 2

        # Works with in: syntax, too:
        if {language: 'Ruby', version: '3.1'} in version: ('3.0'..)
          puts "Pattern-matching is cool"
        end
        # 3.0: syntax error
        # 3.1: Prints "Pattern-matching is cool"
        ```

    - title: Multiple assignment evaluation order change
      kind: change
      summary: L-values in multiple assignment are evaluated before r-values
      reason: |
        Multiple assignment evaluation order was unexpected: the right part of the expression was calculated before the left. While rarely crucial, this still could cause subtle bugs.
      bug: 4443
      code: |
        ```ruby
        def left1
          puts "left1"
          []
        end

        def left2
          puts "left2"
          []
        end

        def right1
          puts "right1"
          1
        end

        def right2
          puts "right2"
          2
        end

        left1[0] = right1
        # Both Ruby 3.0 and 3.1: prints left1, right1 -- the left side calculated first

        left1[0], left2[0] = right1, right2
        # 3.0: prints right1, right2, left1, left2 -- right side calculated first
        # 3.1: prints left1, left2, right1, right2 -- consistent with singular assignment
        ```

  Core Classes and Modules:
    - title: "`Class#subclasses` added"
      category: Class and Module
      kind: addition
      summary: Returns all _direct_ subclasses of the class.
      feature: 18273
      docs: https://docs.ruby-lang.org/en/3.1/Class.html#method-i-subclasses
      code: |
        ```ruby
        class A
        end

        class B < A
        end

        class C < B
        end

        A.subclasses #=> [B] -- only direct descendants, no grand-children

        class << A
        end

        A.subclasses #=> [B] -- singleton class is not included either

        # Dynamic subclasses are included:
        c = Class.new(A)
        A.subclasses
        # => [#<Class:0x00007f3e45907858>, B]

        # Note that `.subclasses` doesn't hold references to the descendants, and therefore doesn't prohibit
        # them from being garbage-collected
        c = nil
        GC.start
        A.subclasses
        # => [B] -- dynamic class is gone
        ```
      notes: |
        Almost till the final release, method `#descendants` (returning all descendants, not only direct one) was also going to be introduced. But then Matz had a [change of mind](https://bugs.ruby-lang.org/issues/14394#note-33) and decided `#subclasses` covers most of the reasonable needs, and `#descendants` introduces too much complexity. It still might be considered for the future versions.
      class: Class

    - title: Refinement class
      category: Class and Module
      kind: addition
      summary: Add `Refinement` class representing `self` inside a `refine` statement.
      bug: 17429
      docs: https://docs.ruby-lang.org/en/3.1/Refinement.html
      class: Refinement

    - title: Deprecate `include`/`extend` inside refinements
      kind: deprecation
      reason: The `include`/`extend` in refinements never worked (refined class wouldn't have the modules included) but were allowed.
      bug: 17429
      class: Module

    - title: Refinement#import_methods
      category: Class and Module
      kind: addition
      summary: New method similar in functionality to `Module#include` for use inside `refine` statements.
      reason: The `include`/`extend` in refinements never worked (refined class wouldn't have the modules included) but were allowed. This method was introduced as compromise replacement, limited in functionality (see **Notes**).
      bug: 17429
      code: |
        ```ruby
        module AsJSON
          def as_json_data
            JSON.parse(to_json, symbolize_names: true)
          end
        end

        Warning[:deprecated] = true # To see the warning below

        module JSONizer
          refine Array do
            include AsJSON
            # warning: Refinement#include is deprecated and will be removed in Ruby 3.2

            import_methods AsJSON
          end

          refine Hash do
            import_methods AsJSON
          end
        end

        using JSONizer

        [:bar, /baz/, Time.now].as_json_data
        # => ["bar", "(?-mix:baz)", "2021-12-25 20:47:29 +0200"]
        {'value' => 1/3r}.as_json_data
        # => {:value=>"1/3"}
        ```
      notes: |
        Unlike module including, `import_methods` works by copying the methods' bytecode to refined objects. Thus only methods defined in Ruby can be imported (because methods defined in C—including core methods—don't have bytecode). This somewhat limits the usability of the feature:

        ```ruby
        module Binread
          # try to temporarily make string into a byte-sequence...
          refine String do
            def each(&)
              each_byte(&)
            end
            import_methods Enumerable
            # Can't import method which is not defined with Ruby code: Enumerable#drop (ArgumentError)
          end
        end
        ```
      class: Refinement

    - title: "`Module#prepend` always moves to front"
      category: Class and Module
      kind: change
      summary: Now, when module is prepended to the class, it always becomes first in the ancestor chain; even if it was already included.
      reason: It was noted that `prepend` is a mechanism of method redefinition that is relied upon to be performed strictly _before_ the module of the class affected; but if the class had the module already ws included (especially in complex systems and indirectly), this becomes unreliable.
      bug: 17423
      docs: https://docs.ruby-lang.org/en/3.1/Module.html#method-i-prepend
      code: |
        ```ruby
        module M
          def foo
            ["In M", *(super rescue nil)]
          end
        end

        class A
          def foo
            ["in A", *(super rescue nil)]
          end
        end

        A.include M
        A.prepend M

        A.ancestors
        # 3.0: => [A, M, Object, Kernel, BasicObject]
        # 3.1: => [M, A, M, Object, Kernel, BasicObject]
        A.new.foo
        # 3.0: => ["in A", "In M"] -- only method from included module is executed
        # 3.1: => ["In M", "in A", "In M"] -- both included AND prepended methods are executed

        # Note that relation is not symmetric: if the `prepend` happened first, `include` wouldn't affect
        # ancestors chain at all:
        class B
          def foo
            ["in B", *(super rescue nil)]
          end
        end

        B.prepend M
        B.include M

        B.ancestors
        # => [M, B, Object, Kernel, BasicObject] -- both in 3.0 and 3.1
        B.new.foo
        # => ["In M", "in B"]
        ```
      class: Module

    - title: "`Module#private`, `#public`, `#protected`, and `#module_function` return their arguments"
      category: Class and Module
      kind: change
      summary: |
        For each of these methods, the following behavior is used:

          * No arguments returns `nil`
          * Single argument is returned
          * Multiple arguments are returned as an array
      reason: Allows to chain method decoration DSLs, like `memoize private :method_name`. Similar in spirit to changes to `attr_reader`/`attr_writer` behavior in Ruby 3.0
      feature: 12495
      docs:
        - https://docs.ruby-lang.org/en/3.1/Module.html#method-i-private
        - https://docs.ruby-lang.org/en/3.1/Module.html#method-i-public
        - https://docs.ruby-lang.org/en/3.1/Module.html#method-i-protected
        - https://docs.ruby-lang.org/en/3.1/Module.html#method-i-module_function
      code: |
        ```ruby
        p private # global private making all the method below private
        # => nil

        p private def m; end
        # => :m

        def m1; end
        def m2; end
        p private :m1, :m2
        # => :m1, :m2

        # Usage:
        require 'memoist'
        extend Memoist

        # This works: because memoize returns :m, and private receives it
        private memoize def m
          # ...
        end

        # In 3.0 this didn't work, but in 3.1, this does:
        memoize private def m
          # ...
        end
        ```
      class: Module

    - title: "`Method`/`UnboundMethod`: `#public?`, `#private?`, `#protected?`"
      kind: addition
      summary: New methods that allow for checking the visibility of a method.
      reason: For exploration, documenting, and metaprogramming (like, defining a wrapper method that would have the same visibility as original method).
      feature: 11689
      docs:
        - https://docs.ruby-lang.org/en/3.1/Method.html#method-i-public-3F
        - https://docs.ruby-lang.org/en/3.1/Method.html#method-i-protected-3F
        - https://docs.ruby-lang.org/en/3.1/Method.html#method-i-private-3F
        - https://docs.ruby-lang.org/en/3.1/UnboundMethod.html#method-i-public-3F
        - https://docs.ruby-lang.org/en/3.1/UnboundMethod.html#method-i-protected-3F
        - https://docs.ruby-lang.org/en/3.1/UnboundMethod.html#method-i-private-3F
      code: |
        ```ruby
        class A
          def m1
          end

          private def m2
          end
        end

        m1 = A.instance_method(:m1)
        # => #<UnboundMethod: A#m1() >
        m1.private?
        # => false
        m1.public?
        # => true

        m2 = A.new.method(:m2)
        # => #<Method: A#m2()>
        m2.private?
        # => true
        ```
      notes: Another idea discussed was just having `Method#visibility`, but it was hard to decide on the method's name and what it should return, while three predicates are more or less obvious.
      class: [Method, UnboundMethod]

    - title: "`Kernel#load` can load code into a specified module"
      kind: addition
      summary: |
        Instead of always using a new anonymous module for `Kernel#load` if the second argument is not `false`/`nil``, use the given module if a module is provided.

        `load(filename, module)` now evaluates `filename`'s code in the context of the `module`.
      reason: The long-requested feature (the request is created almost 10 years ago!) might be useful for implementing simple helper libraries with a few unscoped methods/classes, and then scoping them while loading.
      feature: 6210
      docs: https://docs.ruby-lang.org/en/3.1/Kernel.html#method-i-load
      code: |
        ```ruby
        # Assuming the following file test-load.rb
        ENV={a: 1}

        def puts(*)
          raise NotImplementedError
        end

        class String
          def debug = p("Hello from test string")
        end

        print "Additional module loaded"

        # This would replace `ENV`, `puts` and extend core `String`, and pollute global scope with methods
        load 'test-load.rb'
        # prints "Additional module loaded"
        ENV
        # => {:a=>1}
        'test'.debug
        # prints "Hello from test string"
        puts 'bar'
        # NotImplementedError

        # This would not affect `ENV`, `puts`, and `String`, but the only use of the call would be for side-effects
        load 'test-load.rb', true
        # prints "Additional module loaded"
        ENV
        # => ...system ENV...
        'test'.debug
        # undefined method `debug' for "test":String
        puts 'bar'
        # ...prints as usual

        # 3.1+
        # This would add `ENV`, `puts` and `String` to `Context`, and will make methods available as `foo`
        module M; end
        load 'test-load.rb', M
        # prints "Additional module loaded"
        ENV
        # => ...system ENV...
        M::ENV
        # => {:a=>1}
        M::String.new.debug
        # prints "Hello from test string"
        M.instance_method(:puts)
        # => #<UnboundMethod: M#puts() test-load.rb:3> -- can be used by including M into some other module/class

        # Note that `load` wouldn't load into class:
        class C; end
        load 'test-load.rb', C # the call is successful, but C treated as just truthy value (wrap=true)
        C::ENV
        # uninitialized constant C::ENV (NameError)
        ```
      notes: |
        Scoping into a module is transitive for other `load` calls: if the loaded file `load`s more files, they also will be scoped into the module. But it is not transitive for `require`:

        ```ruby
        # assuming in test-load2.rb
        class Integer
          def debug = p "debug Int"
        end
        # ...and in test-load.rb
        load 'test-load2.rb'

        # then if we do
        module M; end
        load 'test-load.rb', M
        M::Integer.new.debug
        # prints "debug Int"

        # ...but if in test-load.rb we'll have this:
        require './test-load2'
        # ...then
        load 'test-load.rb', M
        M::Integer.debug
        # uninitialized constant M::Integer (NameError)
        1.debug
        # prints "debug Int"
        ```
      class: Kernel

    - title: "`Integer.try_convert` added"
      kind: addition
      summary: Safe explicit conversion method which calls `#to_int` if the argument has it, and returns `nil` otherwise.
      reason: The similar methods exist on a few other core classes, like String and Array. They are useful for implementing polymorphic methods (like `#[]` behaving differently for integer, string and range), as a safe way of type-checking/type-coercion.
      feature: 15211
      docs: https://docs.ruby-lang.org/en/3.1/Integer.html#method-c-try_convert
      code: |
        ```ruby
        Integer.try_convert(1) #=> 1
        Integer.try_convert(1.3) #=> 1
        Integer.try_convert(3/2r) #=> 1
        require 'bigdecimal'
        Integer.try_convert(BigDecimal('100000000000000000000000000000000000000000000000000000000000000'))
        #=> 100000000000000000000000000000000000000000000000000000000000000

        # If the object doesn't have #to_int, returns `nil`
        Integer.try_convert('1') #=> nil

        class MyNumber
          def to_int
            1.3
          end
        end

        # If #to_int doesn't return Integer, the error is raised (even if the result is convertable)
        Integer.try_convert(MyNumber.new)
        #=> `try_convert': can't convert MyNumber to Integer (MyNumber#to_int gives Float) (TypeError)

        # Usage in some array-alike slicing API:
        def slice(index)
          idx = Integer.try_convert(index) or
            raise ArgumentError, "Expected argument convertible to Integer, got #{index}"
          # Now `idx` is safe to use even for low-level APIs like memory addressing, it is definitely
          # Integer, even if some Float was passed initially.
        ```
      class: Integer

    - title: "`String#unpack` and `#unpack1` gain `offset:` argument"
      summary: The new argument allows to unpack data starting from the specified offset.
      kind: addition
      reason: |
        Handy for working with binary data of complicated shape, flow like: read one byte, decide what type/size is next data, then read this number of bytes _starting after the type tag_, then read next chunk _starting after the data already read_. Before the parameter introduction, this type of processing required string slicing, which is cumbersome and might have been inefficient.
      feature: 18254
      docs:
        - https://docs.ruby-lang.org/en/3.1/String.html#method-i-unpack
        - https://docs.ruby-lang.org/en/3.1/String.html#method-i-unpack1
      code: |
        ```ruby
        # imagine it is "type tag 1 + data in four 32-bit integers"
        data = [1, 1991, 1995, 1998, 2003].pack('CL*')
        # => "\x01\xC7\a\x00\x00\xCB\a\x00\x00\xCE\a\x00\x00\xD3\a\x00\x00"
        tag = data.unpack1('c')
        # => 1
        data.unpack('L*', offset: 1)
        # => [1991, 1995, 1998, 2003]

        # Negative offsets or out-of-bounds ones don't work
        data.unpack('L*', offset: -1)
        # in `unpack': offset can't be negative (ArgumentError)
        data.unpack('L*', offset: 20)
        # in `unpack':  offset outside of string (ArgumentError)

        # 0 works, being the same as no offset
        data.unpack('c', offset: 0)
        # => [1]
        ```
      class: String

    - title: "`MatchData#match` and `#match_length` added"
      kind: addition
      summary: |
        `#match(idx)` is the same as `MatchData#[]`, but only works for singular numeric or symbolic index. `#match_length(idx)` returns the length of the `idx`s match.
      reason: It was argued that in the performance-critical code sometimes there is a need to just know the length of the substring matched, and doing it via `match[index].length` leads to creation of an intermediate string soon to be dropped, while `#match_length` doesn't do that. `#match` is added mostly for completeness (it would be weird to not have it when `#match_length` method exists).
      feature: 18172
      docs:
        - https://docs.ruby-lang.org/en/3.1/MatchData.html#method-i-match
        - https://docs.ruby-lang.org/en/3.1/MatchData.html#method-i-match_length
      code: |
        ```ruby
        m = "Ruby 3.1 is released December 25, 2021".match(/Ruby (?<version>\d\.\d) .* (?<year>\d{4})/)
        # => #<MatchData "Ruby 3.1 is released December 25, 2021" version:"3.1" year:"2021">
        m.match(1)
        # => "3.1"
        m.match(:version)
        # => "3.1"
        m.match('version')
        # => "3.1"
        m.match_length(:version)
        # => 3
        m.match(2)
        # => "2021"
        m.match_length(2)
        # => 4
        m.match(3)
        # in `match': index 3 out of matches (IndexError)
        m.match_length(3)
        # in `match_length': index 3 out of matches (IndexError)

        # ...unlike #[]
        m[3]
        # => nil

        # Realistic usage:
        text = "My credit card number is 5221-1234-5678-9000 (not really)"
        text.gsub!(/(\d{4})-(\d{4})-(\d{4})-(\d{4})/) {
          m = Regexp.last_match
          "#{m.match(1)}-#{'*' * m.match_length(2)}-#{'*' * m.match_length(3)}-#{m.match(4)}"
        }
        # => "My credit card number is 5221-****-****-9000 (not really)"
        ```
      class: MatchData

    - title: "`Time.new`, `.at` and `now` gain `in:` argument"
      kind: addition
      highlight: true
      summary: The new parameter is accepting offsets or timezone objects, and (finally!) allows to easily construct time in desired timezone.
      feature: 17485
      docs:
        - https://docs.ruby-lang.org/en/3.1/Time.html#method-c-new
        - https://docs.ruby-lang.org/en/3.1/Time.html#method-c-at
        - https://docs.ruby-lang.org/en/3.1/Time.html#method-c-now
      code: |
        ```ruby
        Time.new(2021, 12, 24, in: '+09:00')
        # => 2021-12-24 00:00:00 +0900
        Time.new(2021, 12, 24, in: 'UTC')
        #  => 2021-12-24 00:00:00 UTC

        # This was previously possible only with "pass all params" signature
        # Ruby 3.0: tz was only a positional argument:
        Time.new(2021, 12, 24, 0, 0, 0, '+09:00')
        # => 2021-12-24 00:00:00 +0900

        # This was previously not possible to do in one call: ::now with timezone
        Time.now(in: '+09:00')
        # => 2021-12-21 18:33:51.583436226 +0900
        Time.now
        # => 2021-12-21 11:34:00.258235705 +0200 -- my local timezone, for comparison

        # This was not possible either: ::at with timezone
        timestamp = Time.now.to_i
        # => 1640079354
        Time.at(timestamp, in: '+09:00')
        # => 2021-12-21 18:35:54 +0900

        # Timezone objects are supported, too
        require 'tzinfo'
        zone = TZInfo::Timezone.get('America/New_York')
        Time.now(in: zone)
        # => 2021-12-21 04:37:25.522169768 -0500
        Time.now(in: zone).zone
        # => #<TZInfo::DataTimezone: America/New_York>
        ```
      class: Time

    - title: "`Time#strftime` supports `-00:00` offset"
      kind: addition
      summary: |
        `%-z` allows to format "negative zero" offset for Time.
      reason: |
        RFC 3339 [defines a nuance](https://datatracker.ietf.org/doc/html/rfc3339#section-4.3) of offset formatting: offset `"+00:00"` in some service response declares that UTC is the preferred timezone for some context; while `"-00:00"` declares that preferred timezone is unknown, that's why data is in UTC.
      feature: 17544
      docs: https://docs.ruby-lang.org/en/3.1/Time.html#method-i-strftime
      code: |
        ```ruby
        t = Time.now.utc
        # => 2021-12-26 18:47:52.979940556 UTC -- yeah, I am still working on a changelog a day after the release :(
        t.strftime('%H:%M%z')
        # => "18:47+0000"
        t.strftime('%H:%M%-z')
        # => "18:47-0000"
        t.strftime('%H:%M%-:z')
        # => "18:47-00:00"
        t.strftime('%H:%M%-::z')
        # => "18:47-00:00:00"
        ```
      class: Time

    - title: "`Struct#new` warns when passing keywords to a non-keyword-initialized struct"
      kind: addition
      reason: After keyword-inited stucts have been introduced, it is easy to forget the actual protocol of some struct, and try to initialized it with keyword arguments—which, if the struct is not keyword-inited, would raise no error, but produce an unexpected result.
      feature: 16806
      code: |
        ```ruby
        Person = Struct.new(:name, :age)
        # Proper initialization:
        Person.new('Jane', 32)
        #=> #<struct Person name="Jane", age=32>

        # I forgot it is not initialized by keywords, expected to initialize both fields,
        # but it would actually be treated as Person.new({name: 'Jane', age: 32}, nil)
        Person.new(name: 'Jane', age: 32)
        # warning: Passing only keyword arguments to Struct#initialize will behave differently from Ruby 3.2. Please use a Hash literal like .new({k: v}) instead of .new(k: v).
        #=> #<struct Person name={:name=>"Jane", :age=>32}, age=nil>

        # If the struct is really initialized by a hash, use {} to signify you know what you do
        Locale = Struct.new(:translations)
        Locale.new({user: 'користувач', application: 'застосунок'})
        # => #<struct Locale translations={:user=>"користувач", :application=>"застосунок"}>
        # ...no warning produced

        # The warning is produced only if the hash is the ONLY argument
        Locale = Struct.new(:lang, :translations)
        Locale.new(:ua, user: 'користувач', application: 'застосунок')
        #=> #<struct Locale lang=:ua, translations={:user=>"користувач", :application=>"застосунок"}>
        # ...no braces necessary, no warning
        ```
      class: Struct

    - title: "`StructClass#keyword_init?` added"
      kind: addition
      summary: New method allows to check whether the `Struct`-produced class is initialized by keywords.
      reason: Helpful for meta-programming and generic processing of data, like serializing/deserializing.
      feature: 18008
      docs: https://docs.ruby-lang.org/en/3.1/Struct.html#method-c-keyword_init-3F
      code: |
        ```ruby
        Struct.new(:name, :age).keyword_init?                       #=> nil
        Struct.new(:name, :age, keyword_init: true).keyword_init?   #=> true
        Struct.new(:name, :age, keyword_init: false).keyword_init?  #=> false

        # Potential usage:
        def deserialize(struct_class, **data)
          if struct_class.keyword_init?
            struct_class.new(**data)
          else
            struct_class.new(*data.values)
          end
        end
        ```
      class: Struct

    - title: "`Enumerable#compact` and `Enumerator::Lazy#compact` added"
      kind: addition
      reason: |
        `#compact` was previously defined only on a particular classes like `Array` and `Hash`, but being a synonym for `reject(&:nil?)`, it is reasonable to have in generic `Enumerable`. Especially useful in lazy enumeration to produce still-lazy sequences with `compact` applied.
      feature: 17312
      docs:
        - https://docs.ruby-lang.org/en/3.1/Enumerable.html#method-i-compact
        - https://docs.ruby-lang.org/en/3.1/Enumerator/Lazy.html#method-i-compact
      code: |
        ```ruby
        # quickly imitate some slow or infinite stream producing data with nils possible:
        stream = Enumerator.produce { [nil, 1, 'test'].sample }.lazy

        stream.compact.first(5)
        # 3.0: NoMethodError (undefined method `compact' for #<Enumerator::Lazy: #<Enumerator: #<Enumerator::Producer:0x000055e8ffd38388>:each>>)
        # 3.1: => ["test", 1, 1, "test", "test"]

        # In 3.0, this already worked, which made absence of .compact even more confusing:
        stream.reject(&:nil?).first(5)
        # => ["test", "test", 1, "test", 1]

        # Usage in regular enumerable objects:
        require 'set'
        Set[1, nil, 2].compact
        # 3.0: NoMethodError (undefined method `compact' for #<Set: {1, nil, 2}>)
        # 3.1: => [1, 2] -- not ideal (it would be better to see Set[1, 2]), but better
        ```
      notes: |
        `Hash`, despite being `Enumerable`, has its own [#compact] method definition since [Ruby 2.4](2.4.html#hashcompact-and-compact), which just removes all key-value pairs where values are `nil`.
      class: [Enumerable, Enumerator::Lazy]

    - title: "`Enumerable#tally` now accepts an optional hash to update"
      kind: addition
      summary: The hash is updated with the new `tally` numbers, allowing to accumulate stats from several enumerables efficiently and succinctly.
      feature: 17744
      docs: https://docs.ruby-lang.org/en/3.1/Enumerable.html#method-i-tally
      code: |
        ```ruby
        week1_shifts = ['John', 'Jane', 'Hassim', 'John', 'Olexa', 'Olexa', 'Jane']
        week2_shifts = ['Jane', 'Jane', 'Miranda', 'John', 'Hassim', 'Olexa', 'John']

        stats = {}
        week1_shifts.tally(stats)
        #=> {"John"=>2, "Jane"=>2, "Hassim"=>1, "Olexa"=>2}
        week2_shifts.tally(stats) # add it to the previous stats
        #=> {"John"=>4, "Jane"=>4, "Hassim"=>2, "Olexa"=>3, "Miranda"=>1}

        # Only hashes or objects implicitly convertible into hash are allowed:
        require 'ostruct'
        week1_shifts.tally(OpenStruct.new) # maybe having #[]= is enough?..
        # in `tally': can't convert OpenStruct to Hash (OpenStruct#to_hash gives NilClass) (TypeError)

        # Hash descendants can be used as argument
        gem 'hashie'
        require 'hashie'
        stats = Hashie::Mash.new # Subclass of Hash which allows `.key` access
        res = week1_shifts.tally(stats)
        # => {"John"=>2, "Jane"=>2, "Hassim"=>1, "Olexa"=>2}
        res.class
        # => Hashie::Mash
        res.John
        # => 2
        ```
      class: Enumerable

    - title: "`Enumerable#each_cons` and `#each_slice` return a receiver"
      kind: addition
      reason: Before 3.1, both methods returned `nil`, making it inconvenient to use in chained computations. This was also inconsistent with `#each`, which returns a receiver.
      github-pull-request: 1509
      docs:
        - https://docs.ruby-lang.org/en/3.1/Enumerable.html#method-i-each_cons
        - https://docs.ruby-lang.org/en/3.1/Enumerable.html#method-i-each_slice
      code: |
        ```ruby
        Item = Struct.new(:value, :next)

        list = ('a'..'e').map { Item.new(_1) }
                        .each_cons(2) { |item, next_item| item.next = next_item }
        # => [
        #   #<struct Item value="a", next=#<struct Item value="b", ...>,
        #   ...
        #   ...

        # Before Ruby 3.1, one would need to write:
        list = ('a'..'e').map { Item.new(_1) }
        # this would return nil, so can't be chained
        list.each_cons(2) { |item, next_item| item.next = next_item }
        ```
      class: Enumerable

    - title: "`Array#intersect?` added"
      kind: addition
      summary: Method checks if two arrays intersect, e.g. have at least one item in common.
      reason: Checking intersection is typical operation (is "current user roles intersect with admin roles?"), but without this method, it typically required to write `!(ary1 & ary2).empty?`, which is cumbersome and produces an intermediate array.
      feature: 15198
      docs: https://docs.ruby-lang.org/en/3.1/Array.html#method-i-intersect-3F
      code: |
        ```ruby
        [1, 2, 3, 4].intersect?([1, 11, 111]) #=> true
        [1, 2, 3, 4].intersect?([11, 111]) #=> false

        # As with other set-alike method, items comparison are performed with #eql? which is in some cases
        # stricter than #==
        [1] == [1.0]
        # => true
        [1].intersect?([1.0])
        # => false
        ```
      notes: |
        * As it is with [&](https://docs.ruby-lang.org/en/3.1/Array.html#method-i-26), the new method treats arrays as sets of values with order ignored, so the semantic is just "if any value of array 1 is present in array 2", not some more strict check (like "if elements at the end of array 1 are the same as elements at the beginning of array 2").
        * The complexity of the method is roughly `O(size1+size2)`.
      class: Array

    - title: "`Thread::Queue#initialize` can accept initial values"
      kind: addition
      reason: Despite the fact that `Thread::Queue` is a specialized collection for safe data exchange in a multi-threaded context, it is considered to frequently have some initial set of values to process (like list of workers), new method call-sequence simplifies that.
      feature: 17327
      docs: https://docs.ruby-lang.org/en/3.1/Thread/Queue.html#method-c-new
      code: |
        ```ruby
        queue = Thread::Queue.new(['task1', 'task2', 'task3'])
        # => #<Thread::Queue:0x00007f434de1b800>

        producer = Thread.new do
          while !queue.empty?
            task = queue.pop
            puts "procesing #{task}"
          end
        end

        producer.join
        # procesing task1
        # procesing task2
        # procesing task3

        # Any class responding to #to_a, and any Enumerable can be used as a constructor:
        queue = Thread::Queue.new(File.open('tasks.csv').each_line)
        # => #<Thread::Queue:0x00007f434de18998>
        ```
      class: Thread::Queue

    - title: "`IO::Buffer` added"
      kind: addition
      highlight: true
      summary: A new class representing low-level I/O abstraction. Internally, uses OS mechanisms to directly use memory-mapping of files and internal Ruby String representation.
      reason: The feature was requested for implementing non-blocking `#io_read` and `#io_write` for `FiberScheduler`, but probably will find other usages once matured.
      feature: 18020
      docs: https://docs.ruby-lang.org/en/3.1/IO/Buffer.html
      code: |
        _This is a big new class, see its docs for detailed examples of usage, they are quite succinct._
      class: IO::Buffer

    - title: "`File.dirname` gains optional `level` param to go up the directory tree"
      kind: addition
      feature: 12194
      docs: https://docs.ruby-lang.org/en/3.1/File.html#method-c-dirname
      code: |
        ```ruby
        path = "/home/zverok/projects/ruby/README.md"
        File.dirname(path)
        # => "/home/zverok/projects/ruby"
        File.dirname(path, 1) # same as above
        # => "/home/zverok/projects/ruby"
        File.dirname(path, 2)
        # => "/home/zverok/projects"
        File.dirname(path, 3)
        # => "/home/zverok"
        File.dirname(path, 100)
        # => "/"
        File.dirname(path, 0) # no-op
        # => "/home/zverok/projects/ruby/README.md"
        File.dirname(path, -1)
        # in `dirname': negative level: -1 (ArgumentError)
        ```
      notes: Unfortunately, [Pathname#dirname](https://docs.ruby-lang.org/en/3.1/Pathname.html#method-i-dirname) is not updated to have a similar new argument.
      class: File

    - title: "`Marshal.load` accepts a `freeze:` option"
      summary: If `freeze:true` is passed, `#load` will return a deeply frozen object graph.
      reason: Besides obvious immutability merits, constructing frozen graph may lead to lower memory consumption, because frozen strings are deduplicated.
      feature: 18148
      docs: https://docs.ruby-lang.org/en/3.1/Marshal.html#method-c-load
      code: |
        ```ruby
        serialized = Marshal.dump(['value1', 'value2', 'value1', 'value2'])

        deserialized = Marshal.load(serialized)
        deserialized.map(&:frozen?)
        # => [false, false, false, false]
        deserialized.map(&:object_id)
        # => [1023900, 1023920, 1023940, 1023960] -- 4 different objects

        deserialized = Marshal.load(serialized, freeze: true)
        deserialized.map(&:frozen?)
        # => [true, true, true, true]
        deserialized.map(&:object_id)
        # => [1039360, 1039380, 1039360, 1039380] -- only 2 different objects, object_ids repeating

        # The only type of objects not frozen are class/module:
        MyType = Struct.new(:a, :b)
        serialized = Marshal.dump(MyType)
        deserialized = Marshal.load(serialized, freeze: true)
        deserialized.frozen? # => false
        # That's because Marshal.load doesn't "create" those objects, just finds the correspondence:
        Object.send(:remove_const, :MyType)
        Marshal.load(serialized)
        # undefined class/module MyType (ArgumentError)
        # ...therefore, making that corresponding module frozen would be unexpected
        ```
      class: Marshal

    - title: "`Thread#native_thread_id` added"
      kind: addition
      category: Concurrency
      summary: Returns OS-specific thread ID.
      reason: The method might be useful for low-level debugging, and for system calls requiring "real" thread id.
      feature: 17853
      docs: https://docs.ruby-lang.org/en/3.1/Thread.html#method-i-native_thread_id
      code: |
        ```ruby
        # On my Ubuntu:

        Thread.current.native_thread_id
        # => 2735439
        t = Thread.new { sleep(1) }
        t.native_thread_id
        # => 2746533
        sleep(5) # -- allow t to finish (non-deterministic though!)
        t.native_thread_id
        # => nil
        ```
      notes: It is documented that `native_thread_id` might change through the thread lifetime in Ruby implementations that use `M:N` threading model (e.g. `M` Ruby threads is mapped on `N` OS threads, with the nature of mapping decided by the interpreter).
      class: Thread

    - title: "`Process._fork` added"
      kind: addition
      category: Concurrency
      summary: The new method is the process forking implementation which is guaranteed to be used by  `Process.fork`, `Kernel#fork`, and `IO.popen`.
      reason: The method is meant to be overridable by libraries that need to add some hook/additional processing (like freeing DB connections) on forking. Previously, this was inconvenient due to the fact that `Process.fork` and `Kernel#fork` were different methods, not relying on each other.
      feature: 17795
      docs: https://docs.ruby-lang.org/en/3.1/Process.html#method-c-_fork
      code: |
        ```ruby
        module ForkMonitor
          def _fork(...)
            puts "Before fork : in #{Process.pid}"
            super.tap { puts "After fork  : in #{Process.pid}" }
          end
        end

        Process.singleton_class.prepend(ForkMonitor)

        puts "Main process: in #{Process.pid}"
        pid = fork { puts "Forked body : in #{Process.pid}" }
        puts "Wating for       #{pid}"
        Process.waitpid(pid) if pid
        ```
        This prints:
        ```
        Main process: in 2052974
        Before fork : in 2052974
        After fork  : in 2052974
        Wating for       2052975
        After fork  : in 2052975  -- note that AFTER code is performed both for parent and child
        Forked body : in 2052975
        ```
      notes: |
        * The method should **never** be called directly; the only reason for it to exist is to be redefinable
        * The method should call `super`, and return what it had returned (it would become a return value of `fork`, e.g. child process' `pid`)
      class: Process

    - title: "Fiber Scheduler: New hooks"
      kind: addition
      highlight: true
      category: Concurrency
      summary: Continuing work on non-blocking Fiber and Fiber Scheduler concept [introduced in 3.0](3.0.html#non-blocking-fiber-and-scheduler), new optional hooks were introduced to support non-blocking DNS resolution (`#address_resolve`), IO (`#io_read`/`#io_write`)
      feature: [17370, 17470, 18020]
      docs:
        - https://docs.ruby-lang.org/en/3.1/Fiber/SchedulerInterface.html#method-i-address_resolve
        - https://docs.ruby-lang.org/en/3.1/Fiber/SchedulerInterface.html#method-i-timeout_after
        - https://docs.ruby-lang.org/en/3.1/Fiber/SchedulerInterface.html#method-i-io_read
        - https://docs.ruby-lang.org/en/3.1/Fiber/SchedulerInterface.html#method-i-io_write
      code: |
        See code examples in 3.0 changelog for general demo of using Fiber Scheduler. As no simple implementation is available, it is complicated to show an example of new hooks in play.
      notes: |
        * Just to remind: Ruby does not include the default implementation of Fiber Scheduler, but the maintainer of the feature, Samuel Williams, provides one in his gem [Async](https://github.com/socketry/async) which is Ruby 3.1-compatible already.
        * `IO::Buffer` introduced to provide a possibility for Fiber scheduler implementations to efficiently do the low-level I/O in a non-blocking manner.
      class: Fiber::SchedulerInterface

    - title: "Ractors can access module instance variables"
      kind: change
      category: Concurrency
      summary: |
        Ractors, introduced in 3.0 to solve a problem of GVM (global virtual matchine lock), have a strict notion of "shareability". Non-main Ractors can't directly access any names defined outside of them except for classes/modules and frozen constants. One improvement was made to this model: allow to access module-wide instance variables.
      reason: |
        Calling `SomeClass.some_method` from inside Ractor is generally OK, unless the method changes the class'/module's internal variables (for example `SomeObject.new` maintains a global cache of all objects constructed)—in this case you'll see an `IsolationError`. So far, it corresponds to expectations of Ractor's data sharing model. But this expectation is broken if some of the module's methods uses immutable data stored in instance variable: intuitively it doesn't break isolation, but still didn't work. Now this limitation is relaxed.
      feature: 17592
      docs: https://docs.ruby-lang.org/en/3.1/Ractor.html#class-Ractor-label-Shareable+and+unshareable+objects
      code: |
        ```ruby
        class APIClient < Struct.new(:version, :use_https, keyword_init: true)
          def self.setup!(**defaults)
            @defaults = defaults.freeze
          end

          def self.make
            new(**@defaults)
          end
        end

        APIClient.setup!(version: 1, use_https: true) # sets immutable instance variable @defaults

        Ractor.new {
          p APIClient.make # uses that variable, should be safe
          # 3.0: in `make': can not access instance variables of classes/modules from non-main Ractors (Ractor::IsolationError)
          # 3.1: => #<struct APIClient version=1, use_https=true>
        }.take
        ```
      class: Ractor

    - title: "`Thread::Backtrace.limit` added"
      kind: addition
      category: Internals
      summary: Returns value set by `--backtrace-limit` command-line option (which is used in Exception#full_message to format backtrace).
      reason: The ability to read the parameter might be useful for custom error formatters.
      feature: 17479
      docs: https://docs.ruby-lang.org/en/3.1/Thread/Backtrace.html#method-c-limit
      code: |
        ```
        $ ruby -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
        −1
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
            from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
            from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
            from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
            from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
            from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
            from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
            from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
            from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
            from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
            from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
            from .../lib/ruby/3.1.0/net/http.rb:998:in `connect'
            from .../lib/ruby/3.1.0/net/http.rb:976:in `do_start'
            from .../lib/ruby/3.1.0/net/http.rb:965:in `start'
            from .../lib/ruby/3.1.0/net/http.rb:627:in `start'
            from .../lib/ruby/3.1.0/net/http.rb:503:in `get_response'
            from .../lib/ruby/3.1.0/net/http.rb:474:in `get'
            from -e:1:in `<main>'

        $ ruby --backtrace-limit 2 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
        2
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
            from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
            from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
            ... 7 levels...
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
            from .../lib/ruby/3.1.0/socket.rb:227:in `foreach'
            from .../lib/ruby/3.1.0/socket.rb:632:in `tcp'
            ... 7 levels...

        $ ruby --backtrace-limit 0 -r net/http -e "p Thread::Backtrace.limit; Net::HTTP.get(URI('http://wrong.address'))"
        0
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': Failed to open TCP connection to wrong.address:80 (getaddrinfo: Name or service not known) (SocketError)
            ... 9 levels...
        .../lib/ruby/3.1.0/socket.rb:227:in `getaddrinfo': getaddrinfo: Name or service not known (SocketError)
            ... 9 levels...
        ```
      class: Thread::Backtrace

    - title: "`GC.measure_total_time`, `.measure_total_time=`, `.total_time`, `.stat` added"
      kind: addition
      category: Internals
      summary: New methods added to measure time spent in garbage collection.
      feature: 10917
      docs:
        - https://docs.ruby-lang.org/en/3.1/GC.html#method-c-measure_total_time
        - https://docs.ruby-lang.org/en/3.1/GC.html#method-c-measure_total_time-3D
        - https://docs.ruby-lang.org/en/3.1/GC.html#method-c-stat
        - https://docs.ruby-lang.org/en/3.1/GC.html#method-c-total_time
      code: |
        ```ruby
        GC.total_time  # => 10903796 -- nanoseconds at script start
        GC.stat[:time] # => 10 -- milliseconds at script start

        30_000.times.map { Object.new }

        GC.start

        # After some GCing
        GC.total_time  # => 20483486 -- nanoseconds
        GC.stat[:time] # => 20 -- milliseconds

        GC.measure_total_time= false

        30_000.times.map { Object.new }

        GC.start

        # Measuring was disabled, same values as above
        GC.total_time  # => 20483486
        GC.stat[:time] # => 20
        ```
      notes: It is stated that measurement can introduce overhead, but _it is enabled by default_.
      class: GC

    - title: "`TracePoint.allow_reentry` added"
      kind: addition
      category: Internals
      summary: Normally, during handling of `TracePoint` event, all other active `TracePoint` handlers wouldn't be called. Since Ruby 3.1, the handler can wrap some of its code into `TracePoint.allow_reentry { ... }` and inside that block, other handlers (including the current one) _will_ be invoked.
      reason: The issue was raised by author of the [byebug](https://github.com/deivid-rodriguez/byebug) debugger. Debugging sessions are implemented with `TracePoint` API, and when the program is inside a debugging session, it is actually inside one of the handlers. Thus, all other libraries relying on `TracePoint` API would not work during the session—and one of them is [zeitwerk](https://github.com/fxn/zeitwerk), Rails code reloader.
      feature: 15912
      docs: https://docs.ruby-lang.org/en/3.1/TracePoint.html#method-c-allow_reentry
      code: |
        ```ruby
        # Without reentry
        # ---------------

        line_handler = TracePoint.new(:line) do |tp| # invoked for each statement
          next if tp.path != __FILE__ # only work in this file
          puts "Line handler"
          binding.eval("class C; end")
        end.enable

        class_handler = TracePoint.new(:class) do |tp| # invoked for each class definition
          puts "Class handler"
        end.enable

        class B
        end

        # This script will print "Class handler" only once: when inside :line
        # handler, all other handlers are ignored, and `class C; end` is NOT invoking the class_handler


        # With reentry
        # ------------

        line_handler = TracePoint.new(:line) do |tp| # invoked for each statement
          next if tp.path != __FILE__ # only work in this file
          next if (__LINE__..__LINE__+3).cover?(tp.lineno) # don't be invoked from itself
          puts "Line handler"
          TracePoint.allow_reentry { binding.eval("class C; end") }
        end.enable

        class_handler = TracePoint.new(:class) do |tp| # invoked for each class definition
          puts "Class handler"
        end.enable

        class B
        end

        # This will print "Class handler" twice: inside allow_reentry block in :line
        # handler, other handlers are enabled.
        ```
      notes: |
        The default behavior (no reentry) is necessary to protect from infinite recursion; when allowing reentry, extreme precautions should be taken (note the second `if` inside `:line` handler: without it, every line inside the handler would invoke itself).
      class: TracePoint

    - title: "`$LOAD_PATH.resolve_feature_path` no longer raises on unfound name"
      kind: change
      category: Internals
      summary: Since being added [in 2.6](2.6.html#rubyvmresolve_feature_path) (then named `RubyVM.resolve_feature_path`), the method have raised when the requested name wouldn't be found. It was fixed in 3.1 to just return `nil`.
      reason: It was argued that raising `LoadError` makes method looks like it has a side effect instead of just being a query method, and makes it inconvenient to use.
      feature: 16043
      docs: https://docs.ruby-lang.org/en/3.1/globals_rdoc.html
      code: |
        ```ruby
        $LOAD_PATH.resolve_feature_path('garbage111')
        # 3.0: LoadError (cannot load such file -- garbage111)
        # 3.1: => nil
        ```

- version: "3.0"
  Language Changes:
    - title: "Keyword arguments are now fully separated from positional arguments"
      kind: change
      highlight: true
      summary: |
        The separation which started in 2.7 with deprecations, is now fully finished. It means keyword arguments are not a "syntax sugar" on top of hashes, and they never converted into each other implicitly:
      feature: 14183
      code: |
        ```ruby
        def old_style(name, options = {})
        end

        def new_style(name, **options)
        end

        new_style('John', {age: 10})
        # Ruby 2.6: works
        # Ruby 2.7: warns: Using the last argument as keyword parameters is deprecated; maybe ** should be added to the call
        # Ruby 3.0: ArgumentError (wrong number of arguments (given 2, expected 1))
        new_style('John', age: 10)
        # => works
        h = {age: 10}
        new_style('John', **h)
        # => works, ** is mandatory

        # The last hash argument still allowed to be passed without {}:
        old_style('John', age: 10)
        # => works
        ```
      notes: There is a [big and detailed explanation](https://www.ruby-lang.org/en/news/2019/12/12/separation-of-positional-and-keyword-arguments-in-ruby-3-0/) of the separation reasons, logic, and edge cases on Ruby site, written at the dawn of 2.7, so we will not go into more details here.
      class: Method

    - title: Procs with "rest" arguments and keywords change of autosplatting behavior
      kind: change
      summary: Just a leftover from the separation of keyword arguments.
      feature: 16166
      code: |
        ```ruby
        block = proc { |*args, **kwargs| puts "args=#{args}, kwargs=#{kwargs}"}
        block.call(1, 2, a: true)
        # Ruby 2.7: args=[1, 2], kwargs={:a=>true} -- as expected
        # Ruby 3.0: args=[1, 2], kwargs={:a=>true} -- same
        block.call(1, 2, {a: true})
        # Ruby 2.7:
        #  warning: Using the last argument as keyword parameters is deprecated
        #  args=[1, 2], kwargs={:a=>true} -- but extracted to keyword args nevertheless
        # Ruby 3.0:
        #  args=[1, 2, {:a=>true}], kwargs={} -- no attempt to extract hash into keywords, and no error/warning
        ```
      class: Proc

    - title: "Arguments forwarding (`...`) supports leading arguments"
      kind: addition
      reason: Argument forwarding, when introduced in 2.7, was able to forward only all-or-nothing. It turned out to be not enough. One of the important usages for leading arguments are cases like `method_missing` and other DSL-defined methods that need to pass to the nested method `:some_symbol` + all of the original arguments.
      feature: 16378
      docs: https://docs.ruby-lang.org/en/master/syntax/methods_rdoc.html#label-Argument+forwarding
      code: |
        ```ruby
        def request(method, url, headers: {})
          puts "#{method.upcase} #{url} (headers=#{headers})"
        end

        def get(...)
          request(:get, ...)
        end

        get('https://example.com', headers: {content_type: 'json'})
        # GET https://example.com (headers={:content_type=>"json"})

        # Leading arguments may be present both in the call and in the definition:
        def logged_get(message, ...)
          puts message
          get(...)
        end

        logged_get('Logging', 'https://example.com', headers: {content_type: 'json'})
        ```
      notes: |
        * "all arguments splat" `...` should be the last statement in the argument list (both on a declaration and a call)
        * on a method declaration, arguments before `...` can only be positional (not keyword) arguments, and can't have default values (it would be `SyntaxError`);
        * on a method call, arguments passed before `...` can't be keyword arguments (it would be `SyntaxError`);
        * make sure to check your punctuation thoroughly, because `anything ...` is a syntax for endless range, those constructs are valid syntax, but would do not what is expected:

          ```ruby
          def delegates(...)
            # call without "()" -- actually parsed as (p()...)
            p ...
            # Prints nothing, but warns: warning: ... at EOL, should be parenthesized?

            # "," accidentally missing after 1, there is just one argument: 1...
            p(1 ...)
            # Prints "1..."

            p(1, ...)
            # Prints, as expected:
            #   1
            #   5
          end

          delegates(5)
          ```
      class: Method

    - title: Single-statement methods can be defined without `end`
      kind: addition
      summary: Methods of exactly one statement now can be defined with syntax `def method() = statement`.
      reason: |
        Ruby's `end`s (unlike C-like languages' `{}`) are generally OK for Rubyists, but make small utility methods look more heavy than they should. For small utility methods with body containing just one short statement like:

        ```ruby
        def available?
          !@internal.empty?
        end
        ```

        ...the "proper" definition might look so heavy that one will decide against it to leave the class more readable (and instead make class' clients to just do `obj.internal.empty?` themselves, making it less semantical). For such cases, a shortcut one-line definition may change the perceiving of utility method creation:

        ```ruby
        def available? = !@internal.any?
        def finished? = available? && @internal.all?(&:finished?)
        def clear = @internal.clear
        ```
      feature: 16746
      docs: https://docs.ruby-lang.org/en/master/syntax/methods_rdoc.html
      code: |
        ```ruby
        def dbg = puts("DBG: #{caller.first}")

        dbg
        # Prints: DBG: test.rb:3:in `<main>'

        # The method definition supports all kinds of arguments:
        def dbg_args(a, b=1, c:, d: 6, &block) = puts("Args passed: #{[a, b, c, d, block.call]}")
        dbg_args(0, c: 5) { 7 }
        # Prints: Args passed: [0, 1, 5, 6, 7]

        # For argument definition, () is mandatory
        def square x = x**2
        # syntax error, unexpected end-of-input -- because Ruby treats it as
        #   def square(x = x**2)
        # ...e.g. an argument with default value, referencing itself, and no method body

        # This works
        def square(x) = x**2
        square(100) # => 10000

        # To avoid confusion, defining method names like #foo= is prohibited
        class A
          # SyntaxError "setter method cannot be defined in an endless method definition":
          def attr=(val) = @attr = val

          # Other suffixes are OK:
          def attr?() = !!@attr
          def attr!() = @attr = true
        end

        # funnily enough, operator methods are OK, including #==
        class A
          def ==(other) = true
        end

        p A.new == 5 # => true

        # any singular expression can be method body

        # This works:
        def read(name) = File.read(name)
                            .split("\n")
                            .map(&:strip)
                            .reject(&:empty?)
                            .uniq
                            .sort

        # Or even this, though, what's the point?..
        def weird(name) = begin
                            data = File.read(name)
                            process(data)
                            true
                          rescue
                            false
                          end

        # inside method body, method calls without parentheses cause a syntax error:
        def foo() = puts "bar"
        #                ^ syntax error, unexpected string literal, expecting `do' or '{' or '('

        # This is due to parsing ambiguity and is aligned with some other places, like
        x = 1 + sin y
        #           ^ syntax error, unexpected tIDENTIFIER, expecting keyword_do or '{' or '('
        ```
      notes: |
        * The initial proposal seems to be a good-natured April Fool's joke, then everybody suddenly liked it, and, with a slight change of syntax, it was accepted;
        * Feature is marked as EXPERIMENTAL, but it does NOT produce a warning, it is deliberate, see discussion in [Misc #17399](https://bugs.ruby-lang.org/issues/17399).
      followup: In Ruby 3.1, the requirement to wrap method calls in parenthesis inside endless method body [was removed](3.1.html#inside-endless-method-definitions-method-calls-without-parenthesis-are-allowed).
      class: Method

    - title: "Pattern matching no longer experimental"
      kind: promotion
      category: Pattern Matching
      summary: Pattern matching, introduced in 2.7, is no longer experimental.
      feature: 17260

    - title: One-line pattern matching with `=>`
      kind: addition
      category: Pattern Matching
      reason: |
        This is an interesting one. Two facts were discussed between 2.7 and 3.0: the fact that in most of the other languages one-line pattern matching has a different order (`<pattern> <operator> <data>`) than introduced in Ruby 2.7 (`<data> in <pattern>`); and the idea of "rightward assignment operator" `=>` for more natural chaining. And then, at some point, ideas converged most fruitfully.
      feature: 17260
      docs: https://docs.ruby-lang.org/en/3.0.0/syntax/pattern_matching_rdoc.html
      code: |
        ```ruby
        # match and unpack:
        {db: {user: 'John', role: 'admin'}} => {db: {user:, role:}}
        p [user, role] # => ["John", "admin"]

        # pattern-matching as a rightward assignment for long experessions:
        File.read('test.txt')
            .split("\n")
            .map(&:strip)
            .reject(&:empty?)
            .first(10) => lines

        p lines # first 10 non-empty lines of the file

        # unpacking+assignment is extremely powerful:
        (1..10).to_a.shuffle => [*before, (2..4) => threshold, *after]
        # ...in input sequence, find first entry in range 2..4, put it into `threshold`,
        # and split parts of the sequence before/after it
        p [before, threshold, after]    # your results might be different due to shuffle :)
        # => [[7, 5, 8], 3, [1, 10, 6, 9, 4, 2]]

        # The things can get really out of hand quickly:
        Time.now.hour => ..9 | 18.. => non_working_hour
        ```
      notes: |
        * Feature is marked as EXPERIMENTAL, will warn so on an attempt of usage, and may change in the future;
        * But simple assignment usage (`data => variable`) is **not** considered experimental and is here to stay;
        * One quirk that might be non-obvious: pattern matching can desconstruct-assign only to local variables, so when using `=>` as an assignment operator, you will see those are syntax errors:
          ```ruby
          some_statement => @x
          some_statement => obj.attr # meaning to call `obj.attr=`
          some_statement => $y # ...though maybe don't use global variables :)
          ```
      followups: |
        * As of 3.1, the feature is no longer experimental;
        * In 3.1, the parenthesis around the pattern became optional

    - title: Pattern matching with `in` as a `true`/`false` check
      kind: addition
      category: Pattern Matching
      summary: After the change described above, `in` was reintroduced to return `true`/`false` (whether the pattern matches) instead of raising `NoMatchingPatternError`.
      reason: The new meaning allows pattern matching to be more tightly integrated with other constructs in the control flow, like iteration and regular conditions.
      feature: 17371
      docs: https://docs.ruby-lang.org/en/3.0.0/syntax/pattern_matching_rdoc.html
      code: |
        ```ruby
        user = {role: 'admin', login: 'matz'}
        if user in {role: 'admin', login:}
          puts "Granting admin scope: #{login}"
        end
        # otherwise just proceed with regular scope, no need to raise

        users = [
          {name: 'John', role: 'user'},
          {name: 'Jane', registered_at: Time.new(2017, 5, 8) },
          {name: 'Barb', role: 'admin'},
          {name: 'Dave', role: 'user'}
        ]
        old_users_range = Time.new(2016)..Time.new(2019)
        # Choose for some notification only admins and old users
        users.select { |u| u in {role: 'admin'} | {registered_at: ^old_users_range} }
        #=> [{:name=>"Jane", :registered_at=>2017-05-08 00:00:00 +0300}, {:name=>"Barb", :role=>"admin"}]
        ```
      notes: |
        * Feature is marked as EXPERIMENTAL, will warn so on an attempt of usage, and may change in the future.
      followups: |
        * As of 3.1, the feature is no longer experimental;
        * In 3.1, the parenthesis around the pattern became optional

    - title: Find patterns
      kind: addition
      category: Pattern Matching
      summary: Pattern matching now supports "find patterns", with several splats in them.
      feature: 16828
      docs: https://docs.ruby-lang.org/en/3.0.0/syntax/pattern_matching_rdoc.html
      code: |
        ```ruby
        users = [
          {name: 'John', role: 'user'},
          {name: 'Jane', role: 'manager'},
          {name: 'Barb', role: 'admin'},
          {name: 'Dave', role: 'manager'}
        ]

        # Now, how do you find admin with just pattern matching?..

        # Ruby 3.0:
        case users
        in [*, {name:, role: 'admin'}, *] # Note the pattern: find something in the middle, with unknown number of items before/after
          puts "Admin: #{name}"
        end
        # => Admin: Barb

        # Without any limitations to choose the value, the first splat is non-greedy:
        case users
        in [*before, user, *after]
          puts "Before match: #{before}"
          puts "Match: #{user}"
          puts "After match: #{after}"
        end
        # Before match: []
        # Match: {:name=>"John", :role=>"user"}
        # After match: [{:name=>"Jane", :role=>"manager"}, {:name=>"Barb", :role=>"admin"}, {:name=>"Dave", :role=>"manager"}]

        # Guard clause does not considered when choosing where to splat:
        case users
        in [*, user, *] if user[:role] == 'admin'
          puts "User: #{user}"
        end
        # => NoMatchingPatternError -- it first put John into `user`,
        # and only then checked the guard clause, which is not matching

        # If the "find pattern" is used (there is more than one splat in the pattern),
        # there should be exactly TWO of them, and they may ONLY be the very first and
        # the very last element:
        case users
        in [first_user, *, {name:, role: 'admin'}, *]
          #                                        ^  syntax error, unexpected *
          puts "Admin: #{name}"
        end

        # Singular splat is still allowe in any place:
        case users
        in [{name: first_user_name}, *, {name: last_user_name}]
          puts "First user: #{first_user_name}, last user: #{last_user_name}"
        end
        # => First user: John, last user: Dave
        ```
      notes: Feature is marked as EXPERIMENTAL, will warn so on an attempt of usage, and may change in the future.

    - title: "Parent classes overwriting class variables raises an error"
      kind: change
      summary: When class `@@variable` is overwritten by the parent of the class, or by the module included, a `RuntimeError` is raised. In addition, top-level class variable access also raises an error.
      reason: Class variables, with their "non-intuitive" access rules, are frequently considered a bad practice. They still can be very useful for tracking something across class hierarchy. But the fact that the entire hierarchy shares the same variable may lead to hard-to-debug bugs, so it was fixed to raise on the usage that seems unintentional.
      bug: 14541
      code: |
        ```ruby
        # Intended usage: parent defines the variable available for all children
        class Good
          @@registry = [] # assume it is meant to store all the children

          def self.registry
            @@registry
          end
        end

        class GoodChild < Good
          def self.register!
            @@registry << self
            @@registry = @@registry.sort # reassigning the value -- but it is still the PARENT's variable
          end
        end

        GoodChild.register!
        p Good.registry # => [GoodChild]

        # Unintended usage: the variable is defined in the child, but then the parent changes it
        class Bad
          def self.corrupt_registry!
            @@registry = []
          end
        end

        class BadChild < Bad
          @@registry = {} # This is some variable which meant to belong to THIS class

          def self.registry
            @@registry
          end
        end

        Bad.corrupt_registry! # Probably unexpected for BadChild's author, its ancestor have changed the variable
        BadChild.registry     # On the next attempt to _access_ the variable the error will be raised
        # 2.7: => []
        # 3.0: RuntimeError (class variable @@registry of BadChild is overtaken by Bad)

        # The same error is raised if the included module suddenly changes class
        module OtherRegistry
          @@registry = {}
        end

        Good.include OtherRegistry
        Good.registry      # On the next attempt to _access_ the variable the error will be raised
        # 2.7: => {}
        # 3.0: RuntimeError (class variable @@registry of Good is overtaken by OtherRegistry)
        ```
      class: Class

    - title: "`$SAFE` and `$KCODE` no longer have any meaning"
      kind: removal
      summary: |
        * `$SAFE`, the global setting related to tainting, was deprecated in 2.7.
        * `$KCODE` also no longer holds any special behavior
      feature: [16131, 17136]

    - title: "`yield` inside a singleton class block now raises an error"
      kind: removal
      summary: This was deprecated in 2.7, and now results in a `SyntaxError` if present
      feature: 15575

    - title: Assigning to a numbered block parameter results in a `SyntaxError`
      kind: change
      summary: Numbered block parameters were introduced in 2.7, and back then raised a warning when you assigned a value to them. Assignment now results in a `SyntaxError`.
      code: |
        ```ruby
        [1,2,3].each{ _1 = "somevalue" }
        #=> In Ruby 2.7:
        #=> warning: `_1' is reserved for numbered parameter; consider another name

        #=> In Ruby 3.0:
        #=> _1 is reserved for numbered parameter (SyntaxError)
        ```

  Core Classes and Modules:
    - title: TODO
